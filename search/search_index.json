{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"MSYS2 Software Distribution and Building Platform for Windows"},{"location":"#_1","title":"Getting Started","text":"<p>MSYS2 is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p> <p>It consists of a command line terminal called mintty, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of Cygwin. Despite some of these central parts being based on Cygwin, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p> <p>To provide easy installation of packages and a way to keep them updated it features a package management system called Pacman, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains more than 2900 pre-built packages ready to install.</p> <p>For more details see 'What is MSYS2?' which also compares MSYS2 to other software distributions and development environments like Cygwin, WSL, Chocolatey, Scoop, ... and 'Who Is Using MSYS2?' to see which projects are using MSYS2 and what for.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Download the installer: msys2-x86_64-20231026.exe</p> <p>For more information on the installer, like command line options, or how to verify the checksum and signature of the installer, see the installer guide.</p> </li> <li> <p>Run the installer. MSYS2 requires 64 bit Windows 8.1 or newer.</p> </li> <li> <p>Enter your desired Installation Folder (short ASCII-only path on a NTFS volume, no accents, no spaces, no symlinks, no subst or network drives, no FAT).</p> <p></p> </li> <li> <p>When done, click Finish.</p> <p></p> </li> <li> <p>Now MSYS2 is ready for you and a terminal for the UCRT64 environment will launch.</p> <p> </p> </li> <li> <p>You will probably want to install some tools like the mingw-w64 GCC to start compiling projects. Run the following command:</p> <pre><code>$ pacman -S mingw-w64-ucrt-x86_64-gcc\n</code></pre> </li> <li> <p>The terminal window will show the output as below. Press 'Enter' to continue:</p> <pre><code>resolving dependencies...\nlooking for conflicting packages...\n\nPackages (15) mingw-w64-ucrt-x86_64-binutils-2.41-2\n            mingw-w64-ucrt-x86_64-crt-git-11.0.0.r216.gffe883434-1\n            mingw-w64-ucrt-x86_64-gcc-libs-13.2.0-2  mingw-w64-ucrt-x86_64-gmp-6.3.0-2\n            mingw-w64-ucrt-x86_64-headers-git-11.0.0.r216.gffe883434-1\n            mingw-w64-ucrt-x86_64-isl-0.26-1  mingw-w64-ucrt-x86_64-libiconv-1.17-3\n            mingw-w64-ucrt-x86_64-libwinpthread-git-11.0.0.r216.gffe883434-1\n            mingw-w64-ucrt-x86_64-mpc-1.3.1-2  mingw-w64-ucrt-x86_64-mpfr-4.2.1-2\n            mingw-w64-ucrt-x86_64-windows-default-manifest-6.4-4\n            mingw-w64-ucrt-x86_64-winpthreads-git-11.0.0.r216.gffe883434-1\n            mingw-w64-ucrt-x86_64-zlib-1.3-1  mingw-w64-ucrt-x86_64-zstd-1.5.5-1\n            mingw-w64-ucrt-x86_64-gcc-13.2.0-2\n\nTotal Download Size:    49.38 MiB\nTotal Installed Size:  418.82 MiB\n\n:: Proceed with installation? [Y/n]\n[... downloading and installation continues ...]\n</code></pre> </li> <li> <p>Now you can call <code>gcc</code> to build software for Windows.</p> <pre><code>$ gcc --version\ngcc.exe (Rev2, Built by MSYS2 project) 13.2.0\n</code></pre> </li> <li> <p>After installing MSYS2 it will update itself via <code>pacman</code>, see the update guide for more information.</p> </li> </ol>"},{"location":"#sponsors","title":"Sponsors","text":"<p>Our main server is sponsored by jsDelivr</p> <p></p> <p>Microsoft Open Source Programs Office sponsors us financially via their FOSS Fund</p> <p></p> <p>Various organizations provide us with mirrors all around the world, see our mirror list for details.</p>"},{"location":"#authors-and-contributors","title":"Authors and Contributors","text":"<ul> <li>Alexpux (Alexey Pavlov)</li> <li>martell (Martell Malone)</li> <li>mingwandroid (Ray Donnelly)</li> <li>Elieux (David Macek)</li> <li>lazka (Christoph Reiter)</li> <li>Renato Silva</li> <li>niXman</li> <li>naveen521kk (Naveen M K)</li> <li>Biswa96 (Biswapriyo Nath)</li> <li>jeremyd2019 (Jeremy Drake)</li> <li>mati865 (Mateusz Miku\u0142a)</li> <li>MehdiChinoune (\u0645\u0647\u062f\u064a \u0634\u064a\u0646\u0648\u0646 / Mehdi Chinoune)</li> </ul>"},{"location":"#donations","title":"Donations","text":"<p>You can donate to the project via GitHub Sponsors:</p> <p></p> <p>or via Open Collective:</p> <p></p>"},{"location":"codeofconduct/","title":"Code of Conduct","text":""},{"location":"codeofconduct/#contact-for-coc-related-issues","title":"Contact for CoC related Issues","text":"<ul> <li>Christoph Reiter reiter.christoph@gmail.com</li> <li>If for some reason you want to contact someone else or if there is no timely   response: David Macek david.macek.0@gmail.com</li> </ul>"},{"location":"codeofconduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"codeofconduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"codeofconduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"codeofconduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"codeofconduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at -&gt; please see \"Contact for CoC related Issues\" above. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"codeofconduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"codeofconduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"codeofconduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"codeofconduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"codeofconduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"codeofconduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by  Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available  at https://www.contributor-covenant.org/translations.</p>"},{"location":"contact/","title":"Support &amp; Contact","text":"<ul> <li>read our news and documentation on this site</li> <li>talk and get help in our Discord server</li> <li>search for and file issues for msys2 packages on GitHub</li> <li>search for and file issues for mingw-w64 packages on GitHub</li> <li>follow our Twitter account</li> <li>follow our Mastodon account</li> <li>[less active] talk in our Matrix room, bridged to our Discord server</li> <li>[less active] talk in our IRC channel, which is also bridged to our Discord server</li> <li>[archived] read older discussion on SourceForge</li> <li>[archived] search for very old tickets on SourceForge</li> <li>[archived] read our mailing list</li> </ul>"},{"location":"contact/#security-contact","title":"Security Contact","text":"<p>For reporting vulnerabilities, managing coordinated security updates, or anything which shouldn't be posted to the public GitHub issue tracker:</p> <ul> <li>Contact: reiter.christoph@gmail.com</li> <li>PGP key for encryption, if needed: https://keyserver.ubuntu.com/pks/lookup?op=vindex&amp;search=0x46BD761F7A49B0EC&amp;fingerprint=on</li> </ul> <p>If there is no timely response please ping us on the other support channels.</p>"},{"location":"get-involved/","title":"Get Involved","text":"<p>Hi. If you're interested in helping the MSYS2 project, we will appreciate it. Please come to our IRC channel #msys2 on OFTC or Matrix room or Discord Server and talk to us. Don't be discouraged if nobody responds straight away, people are often busy or asleep.</p> <p>How can you help:</p> <ul> <li>Prepare and maintain packages</li> <li>Help other users</li> <li>Spread the word</li> <li>Use MSYS2 for your projects</li> <li>Triage bugs</li> <li>Report bugs</li> <li>Fix bugs</li> <li>Upstream patches</li> <li>Improve core packages</li> <li>Write documentation</li> <li>Help with organization or infrastructure</li> <li>Provide mirrors</li> <li>Donated</li> </ul>"},{"location":"license/","title":"License","text":"<p>MSYS2 is a software distribution consisting of several independent parts, each with their own licenses, comparable to a Linux distribution.</p> <p>The installer, for example, is based on the qt-installer-framework and pre-packs the direct and indirect dependencies of the base meta package. Each package has its own licenses.</p> <p>The \"pacman\" package manager in MSYS2 allows users to install other packages available in our repository, each with their own licenses.</p> <p>The license information for each package as visible on https://packages.msys2.org is maintained on a best effort basis and we make no guarantee that it is accurate or complete.</p>"},{"location":"news/","title":"News","text":"<p>This page lists important changes or issues affecting MSYS2 users. We also post them to Twitter and Mastodon, including some not-so-important things :)</p>"},{"location":"news/#2023-11-05-package-installation-issues-for-very-oldoutdated-installations","title":"2023-11-05 - Package installation issues for very old/outdated installations","text":"<p>If you haven't updated pacman in 2.5 years or longer, but are installing new packages, you will see errors like this, due to a format change in the package database:</p> <pre><code>error: mingw-w64-ucrt-x86_64-shared-mime-info: missing required signature\nerror: mingw-w64-ucrt-x86_64-gtk3: missing required signature\nerror: failed to commit transaction (package missing required signature)\nErrors occurred, no packages were upgraded.\n</code></pre> <p>This can be fixed by updating your installation.</p>"},{"location":"news/#2023-08-06-python-changed-behavior-when-loading-dll-dependencies-of-extension-modules","title":"2023-08-06 - Python: Changed behavior when loading DLL dependencies of extension modules","text":"<p>Starting with CPython 3.8, upstream CPython changed their DLL lookup behavior to a safer default when loading extension modules, which meant no longer looking in PATH and the current working directory as a fallback, but requiring code to explicitly add directories containing dependencies via <code>os.add_dll_directory()</code>.</p> <p>Because many packages weren't ported yet back then, and this behavior interfered with our MinGW port build process we reverted this change and kept the old behavior. This had the downsides of being less secure and <code>os.add_dll_directory()</code> not working.</p> <p>We have now finally managed to fix this in our port, so that DLL loading works the same as with the official CPython distribution.</p> <p>If this change is causing problems for you:</p> <ul> <li>Make sure to use <code>os.add_dll_directory()</code> where needed, as recommended by   upstream, see https://docs.python.org/3/library/os.html#os.add_dll_directory   for details</li> <li>To ease the transition we've temporarily added a   <code>PYTHONLEGACYWINDOWSDLLLOADING</code> environment variable, which you can set to <code>1</code>   to get back the old behavior. We will remove this workaround after some time,   so please let us know if there are any problems that can't be solved without   it.</li> </ul>"},{"location":"news/#2023-04-01-llvm-16","title":"2023-04-01 - LLVM 16","text":"<p>LLVM/Clang has now been updated to v16, here are some things to look out for:</p> <ul> <li> <p>Stricter C compiler: Various previously warnings are now errors by default and   might make your build fail. See the following for more information:</p> <ul> <li>The upstream changelog entry: https://releases.llvm.org/16.0.0/tools/clang/docs/ReleaseNotes.html#potentially-breaking-changes</li> <li>The Gentoo guide for how to adjust your code for the new stricter defaults: https://wiki.gentoo.org/wiki/Modern_C_porting</li> <li>The Gentoo bug which tracks all related issues in Gentoo: https://bugs.gentoo.org/870412</li> </ul> </li> <li> <p>autoconf bugs: The stricter defaults in clang v16 exposed some autoconf bugs   which lead to some compiler checks returning the wrong results. We have   backported the respective fixes into all our autoconf versions (2.13, 2.69 and   2.71) and updated autoconf-archive, but this means you will have to run   autoreconf to get those fixes. There is also a chance that other checks in   configure.ac or m4 macros shipped with your project will need to be updated.   So watch out for changes in your configure results.</p> </li> <li> <p>fortran/flang: flang, the llvm based Fortran compiler, is now capable of   building some of our Fortran based packages. But despite that, it still has   known issues of generating wrong or broken code without warnings and should   not be used in production. The same is true for all Fortran based packages we   are building with it.</p> </li> <li> <p>Packages not compatible with llvm v16: So we don't have to wait for all   packages/projects to support the newest llvm version, we added new packages for   llvm v14 and v15 which only contain static builds and are now used by the   packages not supporting llvm v16. This currently affects python-llvmlite,   openshadinglanguage and include-what-you-use.</p> </li> </ul>"},{"location":"news/#2023-02-10-server-maintenance-on-2023-02-1819","title":"2023-02-10 - Server maintenance on 2023-02-18/19","text":"<p>There will be a short server maintenance around the weekend of 2023-02-18/19 which will affect repo.msys2.org, mirror.msys2.org, packages.msys2.org, and some subdomain redirects of our website.</p> <p>Update: all done now</p>"},{"location":"news/#2023-01-15-dropping-support-for-windows-7-and-80","title":"2023-01-15 - Dropping support for Windows 7 and 8.0","text":"<p>As announced last April we will no longer support Windows 7 / 8.0 from now on.</p>"},{"location":"news/#2023-01-15-openssl-updated-from-111-to-30x","title":"2023-01-15 - OpenSSL updated from 1.1.1 to 3.0.x","text":"<p>With v3.0 being out for more than a year and the EOL of v1.1.1 approaching this year we have moved both cygwin and mingw builds to v3.0.x now. If there are any issues let us know.</p> <p>Note that the license of OpenSSL has changed to Apache-2.0 starting with v3.</p>"},{"location":"news/#2023-01-05-dropping-32bit-support-for-qt-6","title":"2023-01-05 - Dropping 32bit support for Qt 6","text":"<p>Qt project dropped support for Windows version older than Windows 10 from Qt 6, see this official blog post. It was also added that we will not have 32 bit x86 Windows support available. With this above condition, we too have very few users who are using 32 bit x86 Windows 10. So, we decided to remove 32 bit builds for Qt 6 and their dependencies. The remaining 32 bit x86 packages which depends on Qt will be linked with Qt 5. With this, our Qt 6 packages will be available for all official Windows platforms.</p>"},{"location":"news/#2022-12-26-default-_win32_winnt-bumped-to-windows-81-for-ucrt-environments","title":"2022-12-26 - Default <code>_WIN32_WINNT</code> bumped to Windows 8.1 for UCRT environments","text":"<p>We have bumped the default <code>_WIN32_WINNT</code> version defined in mingw-w64 from Windows 7 to Windows 8.1 for non-arm UCRT environments (CLANG32, CLANG64, UCRT64). For projects that don't define their own <code>_WIN32_WINNT</code> and conditionally include features depending on the minimum supported Windows version this might mean that new builds will start depending on Windows 8.1. MINGW32/64 will default to Windows 7 for a bit longer to smooth over the transition.</p> <p>This is part of our goal to phase out Windows 7 support and target newer Windows versions by default.</p>"},{"location":"news/#2022-12-16-dropping-windows-7-support-for-the-msys2-installer","title":"2022-12-16 - Dropping Windows 7 support for the MSYS2 installer","text":"<p>The latest release of the MSYS2 installer (v2022-12-16) has dropped support for Windows 7. It will show an error message and abort if started on Windows 7.</p>"},{"location":"news/#2022-10-29-changing-the-default-environment-from-mingw64-to-ucrt64","title":"2022-10-29 - Changing the default environment from MINGW64 to UCRT64","text":"<p>About 1.5 years ago we started adding a new variant of the MINGW64 environment called UCRT64, which uses the Universal CRT instead of the old msvcrt.dll. Now that all our packages are available in this new environment and a very large percentage of our users (~97%) are on a system that includes UCRT, we recommend it as the default environment instead of MINGW64.</p> <p>The MINGW32/64 environments will continue to exist and there are no plans to remove them, but we will focus our attention more on UCRT64 and the other UCRT-using environments such as CLANG64 and CLANGARM64.</p>"},{"location":"news/#2022-10-23-mingw-packages-now-built-with-d_fortify_source2-and-fstack-protector-strong","title":"2022-10-23 - mingw packages now built with <code>-D_FORTIFY_SOURCE=2</code> and <code>-fstack-protector-strong</code>","text":"<p>Our mingw packages will be built with <code>-D_FORTIFY_SOURCE=2</code> and <code>-fstack-protector-strong</code> from now on.</p>"},{"location":"news/#2022-10-18-new-minimum-hardware-requirements-cpus-from-20067","title":"2022-10-18 - New minimum hardware requirements (CPUs from ~2006/7+)","text":"<p>As a first step of phasing out support for Windows 7, we're raising the minimum hardware requirements to match Windows 8.1, which roughly equals Intel Core 2 / AMD Phenom, so anything after 2006/7 is fine.</p> <p>In terms of GCC/Clang compiler flags this means going from <code>-march=x86-64</code> to <code>-march=nocona -msahf</code>. This only affects 64bit packages, and only those that use features only available in those newer CPUs, and only once they are updated or rebuilt.</p>"},{"location":"news/#2022-10-10-libssp-is-no-longer-required","title":"2022-10-10 - libssp is no longer required","text":"<p>Building with <code>_FORTIFY_SOURCE</code> no longer requires explicitly linking with libssp (-lssp) and enabling stack protection no longer pulls in libssp. This brings things in line with other platforms. Thanks to Martin Storsj\u00f6 for implementing this in mingw-w64. Once all our affected packages are rebuilt we will remove the libssp package from our repo.</p> <p>2022-10-13: We have decided to keep just the libssp DLL around for some more time to avoid breaking existing users</p>"},{"location":"news/#2022-09-24-changed-behavior-for-empty-env-vars","title":"2022-09-24 - Changed behavior for empty env vars","text":"<p>Empty environment variables are no longer removed when starting a new non-cygwin process.</p> <pre><code>$ FOO= python -c \"import os; print('FOO' in os.environ)\" # Old\nFalse\n$ FOO= python -c \"import os; print('FOO' in os.environ)\" # New\nTrue\n</code></pre> <p>You can revert to the old behavior by setting <code>MSYS=noemptyenvvalues</code>. Please let us know if this is breaking anything that can't be solved by just unsetting the env var where needed.</p>"},{"location":"news/#2022-09-24-conpty-support-enabled-by-default","title":"2022-09-24 - ConPTY support enabled by default","text":"<p>ConPTY support in our cygwin fork is now enabled by default. This means any non-cygwin apps will now behave as if they are run in with a console attached and not redirected. This feature has been enabled in upstream cygwin for quite a while but we wanted to wait until there are no more known issues. We now feel that not enabling it causes more problems then enabling it.</p> <p>You can disable it again by setting <code>MSYS=disable_pcon</code>.</p>"},{"location":"news/#2022-04-06-windows-7-8-support-will-be-dropped-late-2022-or-early-2023","title":"2022-04-06 - Windows 7 / 8 support will be dropped late 2022 or early 2023","text":"<p>Cygwin 3.5 will drop support for Windows &lt;8.1, which means the new requirement will be \"64 bit Windows 8.1 / Windows Server 2012 R2\". We expect the update to Cygwin 3.5 to be around late 2022, early 2023. For more information, look here.</p> <p>A recent survey suggests that ~2-3% of our active users (excluding cloud servers and CI systems) are still using Windows &lt;8.1. We recommend them stopping to update at the end of the year. We've enabled an inline warning message for them when they open a terminal.</p> <p>For developers bundling our packages, we recommend simply pointing out the last version of their application that still worked with Windows 7 / 8 on their download page.</p>"},{"location":"news/#2022-03-04-sunsetting-the-sourceforge-mirror-in-30-days-from-now","title":"2022-03-04 - Sunsetting the SourceForge mirror in 30 days from now","text":"<p>Note: This should only affect systems not updated in over a year, or users that actively switched to this mirror, which is unlikely.</p> <p>Due to space constrains and our ever growing package archive we can no longer update the SourceForge mirror. We already hit the space limit last year but worked around it by no longer syncing source packages. We have now hit the limit again, and decided that it is no longer worth it maintaining it.</p> <p>We will remove the SourceForge mirror on 2022-04-03. We will delete the package databases as well to make DB syncs fail to avoid users using outdated software without them knowing it. After 4 more weeks we will delete the remaining packages and installers.</p> <p>2022-05-07: The mirror has now been removed.</p>"},{"location":"news/#2022-02-24-repomsys2org-only-available-via-httpstls","title":"2022-02-24 - repo.msys2.org only available via HTTPS/TLS","text":"<p>We have switched repo.msys2.org to always redirect to a secure connection. If for some reason you require HTTP you can use one of our tier 1 mirrors.</p>"},{"location":"news/#2021-12-22-ongoing-cleanup-of-the-base-devel-package-group","title":"2021-12-22 - Ongoing Cleanup of the <code>base-devel</code> Package Group","text":"<p>The <code>base-devel</code> package group is the set of packages required to be installed before running <code>makepkg</code> / <code>makepkg-mingw</code>. We have recently started to clean this group up and moved some of the packages to be explicit dependencies in the <code>PKGBUILD</code> files instead.</p> <p>One notable removal is various autotools related packages. There now exists an <code>autotools</code> and a <code>${MINGW_PACKAGE_PREFIX}-autotools</code> meta package which will pull in anything related to autotools which packages can add to their <code>makedepends</code>.</p> <p>Further more the group was replaced with a package of the same name, to make adding/removing packages easier. Note that pacman prefers packages over groups for the same name, so the set of included packages is now listed here https://packages.msys2.org/package/base-devel</p> <p>This cleanup can lead to build errors in case your build setup assumes certain packages being installed with <code>base-devel</code>. If that is the case make sure to install those missing packages explicitly instead.</p>"},{"location":"news/#2021-12-21-potential-incompatibilities-with-newer-python-setuptools","title":"2021-12-21 - Potential Incompatibilities with newer Python setuptools","text":"<p>tl;dr: use <code>export SETUPTOOLS_USE_DISTUTILS=stdlib</code> if you have problems building/installing packages with newer versions of setuptools from pypi.</p> <p>The Python packaging ecosystem is currently in the transition of removing distutils from CPython and moving it into setuptools. Historically distutils is patched quite a bit by us to make it work with our directory layout and to build packages with gcc/clang instead of MSVC. With this move our patches are no longer used and setuptools will fail in various ways, or install things into wrong places.</p> <p>We are working with upstream to include our patches, but this will take some more time. In the meantime you can force setuptools to use the (still patched) distutils from the CPython stdlib via <code>export SETUPTOOLS_USE_DISTUTILS=stdlib</code> The setuptools version in our repo however will continue to use the patched distutils until all issues are resolved and is not affected.</p> <p>\ud83d\ude4f Many thanks to the distutils and setuptools maintainers for considering our patches, despite Cygwin/MSYS2 not being officially supported by CPython.</p>"},{"location":"news/#2021-10-14-openssh-88-dropped-support-for-old-ssh-rsa-keys-using-sha-1","title":"2021-10-14 - OpenSSH 8.8 dropped support for old ssh-rsa keys using SHA-1","text":"<p>The recent OpenSSH update disabled support for old ssh-rsa keys using SHA-1 by default. See https://www.openssh.com/txt/release-8.8 \"Potentially-incompatible changes\" for details and possible workarounds.</p>"},{"location":"news/#2021-07-04-some-mirrorserverrepository-changes","title":"2021-07-04 - Some Mirror/Server/Repository Changes","text":"<p>Primary Pacman Server: We've switched the main server in the pacman config to https://mirror.msys2.org. This server will redirect pacman to an up-to-date mirror near you for each file. We hope this will improve the download speed for users further away from Europe. We also have a new overview of all mirrors here.</p> <p>Repo Path Renaming: We've renamed <code>mingw/i686/</code> to <code>mingw/mingw32/</code> and <code>mingw/x86_86/</code> to <code>mingw/mingw64/</code> and added symlinks for the old paths. This means 100GB of resyncing for mirrors using rsync (sorry :/). Having the repo name in the directory path allows us to have one mirrorlist configuration for all repos in the future.</p> <p>Sourceforge: Due to space constraints we no longer host the source packages on Sourceforge. They are still available on our main server and on all mirrors.</p>"},{"location":"news/#2021-04-21-rip-mingwandroid","title":"2021-04-21 - R.I.P. mingwandroid","text":"<p>Ray Donnelly is a co-founder and developer of MSYS2 and after a multi year fight with cancer passed away on 2021-04-20.</p> <p></p> <p>If you want to know more about his life and work see his fundraiser descriptions:</p> <ul> <li>https://www.gofundme.com/f/help-Ray-fund-a-hospice-bedroom</li> <li>https://www.gofundme.com/f/arku72-help-ray-fight-cancer</li> </ul> <p>He was always helpful, knowledgeable, and friendly, and he will be greatly missed.</p>"},{"location":"news/#2021-03-25-temporarily-broken-msys2-launcher-package","title":"2021-03-25 - Temporarily broken msys2-launcher package","text":"<p>The repo contained a broken msys2-launcher package for a few hours today causing things like \"msys2.exe\" to just show an error dialog. You can get back to a working setup this way:</p> <ul> <li>Start <code>C:/msys64/msys2_shell.cmd</code> to get a shell</li> <li>Run <code>pacman -Suy</code> to get all the fixed packages</li> </ul>"},{"location":"news/#2021-02-27-new-server-for-repomsys2org-and-packagesmsys2org","title":"2021-02-27 - New server for repo.msys2.org and packages.msys2.org","text":"<p>We have moved repo.msys2.org (and package.msys2.org) to a new server.  There was a short downtime, but everything should be running great now.  Big thanks to appfleet.com jsdelivr.com for sponsoring the new server.</p> <p>New mirrorlists for Pacman will be published soon.  After you get them, your package installs and updates should be faster than before and without the 404s and glitches.</p> <p>With the migration, Christoph (@lazka) will now be updating and signing the Pacman databases more often.  This should go smoothly as the GPG keys are already in place and the process has been tested on the new server before it went live.</p> <p>By the way, the redirect domain msys2.org (no www.) should work more reliably now and HTTPS is now available for it.</p>"},{"location":"news/#2021-01-31-aslr-enabled-by-default","title":"2021-01-31 - ASLR enabled by default","text":"<p>About 5 months ago we started backporting patches to our binutils 2.35 to allow enabling ASLR support via various flags. We also enabled these flags in our build system, so any package in our repo that was updated in the last 5 months has ASLR support enabled.</p> <p>We've now updated to 2.36 which has ASLR enabled by default. Ideally you shouldn't notice any changes, but in case this leads to problems all of it can be disabled/reverted via linker flags:</p> <ul> <li>mingw64: <code>-Wl,--disable-dynamicbase,--disable-high-entropy-va,--default-image-base-low</code></li> <li>mingw32: <code>-Wl,--disable-dynamicbase</code></li> </ul> <p>Note that this is only a temporary workaround and some of these flags will not be available forever, so you should either fix your code or file a bug in case you suspect a toolchain issue.</p> <p>Thanks to the binutils developers for improving/fixing ASLR support and to everyone helping on the MSYS2 side of things, especially Jeremy Drake for backporting, upstreaming and fixing bugs exposed by these changes.</p> <p>Known issues:</p> <ul> <li>(Fixed now) In case you are seeing errors such as <code>relocation truncated to fit:   IMAGE_REL_AMD64_REL32 against undefined symbol</code> try building with   <code>-Wl,--default-image-base-low</code>. Here is the upstream bug report:   https://sourceware.org/bugzilla/show_bug.cgi?id=26659</li> </ul>"},{"location":"news/#2020-12-26-zstd-exemption-for-core-packages-removed","title":"2020-12-26 - Zstd exemption for core packages removed","text":"<p>Given it's been months since we began the switch to Zstd for compressing packages, we've now started using it for core packages as well.  This means older installations without Zstd support won't be able to cleanly upgrade anymore.</p> <p>@dmn-star compiled these commands that should update an older installation to support Zstd and unblock futher upgrades:</p> <pre><code>pacman --noconfirm -U \"https://repo.msys2.org/msys/x86_64/libzstd-1.4.4-2-x86_64.pkg.tar.xz\"\npacman --noconfirm -U \"https://repo.msys2.org/msys/x86_64/zstd-1.4.4-2-x86_64.pkg.tar.xz\"\npacman --noconfirm -U \"https://repo.msys2.org/msys/x86_64/pacman-5.2.1-6-x86_64.pkg.tar.xz\"\n</code></pre>"},{"location":"news/#2020-10-08-main-repo-pruned","title":"2020-10-08 - main repo pruned","text":"<p>Due to limited space on the new server and SourceForge file hosting, we are starting to remove older unused packages from the archives.  There should still be a 1 year's worth of packages available for downgrades.  Mirrors are free to choose whether they want to keep everything or follow the lead.</p>"},{"location":"news/#2020-10-07-server-downtime","title":"2020-10-07 - server downtime","text":"<p>From Friday 2<sup>nd</sup> to Wednesday 10<sup>th</sup>, the main hosting at repo.msys2.org was down. The server unfortunately completely died and the hosting had to be moved elsewhere.  We thank Diablo-D3 for having provided the hardware and hosting.  If you notice anything wrong with repo.msys2.org since the move, please tell us.</p>"},{"location":"news/#2020-06-29-new-packagers","title":"2020-06-29 - new packagers","text":"<p>Alexey is stepping down from his role as the main packager and two new packagers have been appointed in his place:</p> <ul> <li>David Macek with signing key 0x9078f532</li> <li>Christoph Reiter with signing key 0xa0aa7f57</li> </ul> <p>You can see the keys in full without relying on keyservers in the msys2-keyring GitHub repository.</p> <p>We have released a new msys2-keyring package from that source (and a new installer that includes them) and we are waiting for a bit before uploading new databases and packages to give people time to update.  If you don't update the keyring in time, you'll see something like this:</p> <pre><code>:: Synchronizing package databases...\ndownloading mingw32.db...\ndownloading mingw32.db.sig...\nerror: mingw32: key \"4A6129F4E4B84AE46ED7F635628F528CF3053E04\" is unknown\n:: Import PGP key 4096R/87771331B3F1FF5263856A6D974C8BE49078F532, \"David Macek &lt;david.macek.0@gmail.com&gt;\", created: 2018-01-14? [Y/n]\nerror: mingw32: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\nerror: failed to update mingw32 (invalid or corrupted database (PGP signature))\n\ndownloading mingw64.db...\ndownloading mingw64.db.sig...\nerror: mingw64: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\nerror: failed to update mingw64 (invalid or corrupted database (PGP signature))\n\ndownloading msys.db...\ndownloading msys.db.sig...\nerror: msys: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\nerror: failed to update msys (invalid or corrupted database (PGP signature))\nerror: failed to synchronize all databases\n\nerror: mingw32: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\nerror: mingw64: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\nerror: msys: signature from \"David Macek &lt;david.macek.0@gmail.com&gt;\" is marginal trust\n</code></pre> <p>We have prepared the following steps to verify and install the new keyring manually after which you should be able to use <code>pacman -Syu</code> again:</p> <pre><code>$ curl -O https://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz\n$ curl -O https://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig\n\n$ pacman-key --verify msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig\n==&gt; Checking msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig... (detached)\ngpg: Signature made Mon Jun 29 07:36:14 2020 CEST\ngpg:                using DSA key AD351C50AE085775EB59333B5F92EFC1A47D45A1\ngpg: Good signature from \"Alexey Pavlov (Alexpux) &lt;alexpux@gmail.com&gt;\" [full]\n\n# pacman -U msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz\n</code></pre> <p>If you can't even import the key and the above command fails like this:</p> <pre><code>error: msys: key \"4A6129F4E4B84AE46ED7F635628F528CF3053E04\" is unknown\n:: Import PGP key 4A6129F4E4B84AE46ED7F635628F528CF3053E04? [Y/n]\n[...]\nerror: database 'msys' is not valid (invalid or corrupted database (PGP signature))\nloading packages...\nerror: failed to prepare transaction (invalid or corrupted database)\n</code></pre> <p>... you have to convince pacman to not care about those databases for a while, for example like this:</p> <pre><code># pacman -U --config &lt;(echo) msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz\n</code></pre> <p>If you still see signature errors, resetting your pacman key store might help:</p> <pre><code># rm -r /etc/pacman.d/gnupg/\n# pacman-key --init\n# pacman-key --populate msys2\n</code></pre>"},{"location":"news/#2020-06-15-new-base-metapackage-pacman-contrib-is-now-separate","title":"2020-06-15 - New <code>base</code> metapackage; <code>pacman-contrib</code> is now separate","text":"<p>Following a similar change in Arch Linux, the <code>base</code> group was replaced with a <code>base</code> metapackage.  If you installed your MSYS2 using an installer older than 2020-06-02, please run <code>pacman -S base</code> to get up to date.</p> <p>This also installs the <code>pacman-contrib</code> package where <code>updpkgsums</code>, <code>pactree</code> etc. now live (previously included in the <code>pacman</code> package).</p> <p>Details at #1979, #1976 and #1988.</p>"},{"location":"news/#2020-05-31-update-may-fail-with-could-not-open-file","title":"2020-05-31 - Update may fail with \"could not open file\"","text":"<p>In case your update process errors out with something similar to</p> <p>error: could not open file /var/cache/pacman/pkg/zstd-1.4.5-1-x86_64.pkg.tar.zst: Child process exited with status 127</p> <p>update pacman separately first:</p> <pre><code>pacman -Sydd pacman\n</code></pre> <p>This issue is caused by a pacman version that is too old and can't handle newer packages compressed with zstd. In case you are seeing this problem in CI consider using a newer base which contains a newer pacman which supports zstd: https://github.com/msys2/msys2-installer/releases</p>"},{"location":"news/#2020-05-22-msys2-may-fail-to-start-after-a-msys2-runtime-upgrade","title":"2020-05-22 - MSYS2 may fail to start after a msys2-runtime upgrade","text":"<p>MSYS2 programs will fail to start if programs started before the update are still running in the background (especially sshd, dirmngr, gpg-agent, bash, pacman and mintty). You can stop them by running the following in a Windows terminal:</p> <pre><code>taskkill /f /fi \"MODULES eq msys-2.0.dll\"\n</code></pre> <p>If that fails, try a reboot.</p> <p>We've improved our update process so this shouldn't happen again with future updates.</p>"},{"location":"news/#2020-05-22-pacman-may-fail-to-install-packages-with-unrecognized-archive-format","title":"2020-05-22 - Pacman may fail to install packages with <code>Unrecognized archive format</code>","text":"<p>For a while, the core packages were prematurely packaged using zstd without giving users time to update to zstd-enabled pacman first.  This should be resolved now.</p>"},{"location":"news/#2020-05-17-32-bit-msys2-no-longer-actively-supported","title":"2020-05-17 - 32-bit MSYS2 no longer actively supported","text":"<p>32-bit mingw-w64 packages are still supported, this is about the POSIX emulation layer, i.e. the runtime, Bash, MinTTY...</p> <p>After this date, we don't plan on building updated msys-i686 packages nor releasing i686 installers anymore.  This is due to increasingly frustrating difficulties with limited 32-bit address space, high penetration of 64-bit systems and Cygwin (our upstream) starting their way to drop 32-bit support as well.</p>"},{"location":"news/#2019-06-03-mingw-w64-ada-and-objc-unsupported-until-further-notice","title":"2019-06-03 - mingw-w64 Ada and ObjC unsupported until further notice","text":"<p>Pacman may say this when updating:</p> <pre><code>looking for conflicting packages...\nerror: failed to prepare transaction (could not satisfy dependencies)\n:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.3.0-2' required by mingw-w64-x86_64-gcc-ada\n:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.3.0-2' required by mingw-w64-x86_64-gcc-objc\n:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=8.3.0-2' required by mingw-w64-i686-gcc-ada\n:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=8.3.0-2' required by mingw-w64-i686-gcc-objc\n</code></pre> <p>Ada and ObjC are currently unsupported in MSYS2 builds due to long-standing issues with the i686 variant.  Run <code>pacman -R mingw-w64-x86_64-gcc-ada mingw-w64-x86_64-gcc-objc</code> and/or <code>pacman -R mingw-w64-i686-gcc-ada mingw-w64-i686-gcc-objc</code>, then update.</p>"},{"location":"news/#2016-core-update-integrated-into-pacman-update-core-removed","title":"2016 - Core update integrated into Pacman; <code>update-core</code> removed","text":"<p>The function of <code>update-core</code> is transferred to <code>pacman -Syuu</code>.</p>"},{"location":"news/#2016-command-window-may-linger-after-startup","title":"2016 - Command window may linger after startup","text":"<p>Change the argument <code>/K</code> to <code>/C</code> in all three Start menu shortcuts.</p>"},{"location":"privacy/","title":"Privacy","text":""},{"location":"privacy/#pacman-mirrors","title":"Pacman &amp; Mirrors","text":"<p>In the default configuration pacman will connect to \"mirror.msys2.org\" when updating/installing packages and transmit the IP address, the requested file, as well as a user agent in the form of \"pacman/6.0.1 (MSYS_NT-10.0-19042 x86_64) libalpm/13.0.1\". This means the target server will receive the following information:</p> <ul> <li>The IP address</li> <li>The package/database requested for download</li> <li>The pacman version</li> <li>The Windows version, including the Windows build number</li> <li>The architecture of the pacman installation</li> </ul> <p>\"mirror.msys2.org\" will then redirect the request to a tier 1 mirror which will receive the same information again. To prevent requests going to third party mirrors you can reduce the mirror list to just \"repo.msys.org\".</p>"},{"location":"privacy/#logging","title":"Logging","text":"<p>We log the above listed information for every request to \"msys2.org\", including a timestamp, and keep it for up to two weeks for the following reasons:</p> <ul> <li>Debugging and abuse detection</li> <li>Creation and publication of anonymised usage reports:<ul> <li>Overall popularity of requested packages and package types, based on the IP and request path</li> <li>Distribution of Windows/pacman versions used, based on the IP and the user agent</li> <li>Distribution of cloud/non-cloud users, based on the IP</li> </ul> </li> </ul> <p>For what mirrors log, store or process see their respective websites.</p>"},{"location":"privacy/#packages","title":"Packages","text":"<p>Software packaged in our repository might talk to third party servers for functional, analytics, or other reasons. Please see the respective upstream documentation for details.</p>"},{"location":"dev/accounts/","title":"Accounts and Ownership","text":"<p>All the accounts and services which are associated with the MSYS2 project, including who has access and manages them.</p> <ul> <li>domains: msys2.org, msys2.net, msys2.com registered through Hover to Elieux, same for mingw-w64.org and mingw-w64.net</li> <li>Twitter: @msys2org registered to Lazka</li> <li>Mastodon: @msys2org@fosstodon.org registered to Lazka</li> <li>GitHub: msys2 org with multiple owners, msys2-contrib org with multiple owners</li> <li>SourceForge: msys2 project with admins Alexey, Elieux, Lazka</li> <li>server: sponsored by JSDelivr, root access given to Elieux and Lazka</li> <li>file backup server: Hetzner Storage Box, managed by Lazka</li> <li>OpenCollective: msys2 project with Lazka and Elieux as admins</li> <li>Discord:\u00a0https://discord.gg/jPQdRdDcT9\u00a0owned by Lazka, admins Lazka and Elieux</li> <li>Matrix: <code>#msys2_msys2:gitter.im</code> with admin access through GitHub, as well as Lazka and Biswa96 via matrix.org accounts</li> <li>IRC: <code>#msys2</code> registered on OFTC to Elieux, Alexey, <code>#msys2</code> registered on Libera Chat to Elieux, <code>#msys2</code> registered on Freenode to Elieux</li> </ul> <p>Lazka and Elieux have each other's backup contact authorized to solve ownership issues.</p> <p>Some of the services cost money, we keep track of that here: https://github.com/msys2/finances</p>"},{"location":"dev/build-process/","title":"Automated Build Process","text":"<p>The following graph shows what happens between a PKGBUILD getting changed in git and the built package being available in the pacman repo.</p> <pre><code>sequenceDiagram\n    participant GIT as MSYS2/&lt;br&gt;MINGW-packages\n    participant API as packages.msys2.org\n    participant GHA as GitHub Actions\n    participant DT as msys2-autobuild\n    participant DEV as Developer\n    participant REPO as Pacman Repo\n\n    GIT-&gt;&gt;GHA: GIT push trigger\n    GHA-&gt;&gt;GHA: parse PKGBUILDs\n    GHA--&gt;&gt;GIT: upload parsed PKGBUILDs\n\nloop Every 5 minutes\n    API-&gt;&gt;GIT: fetch parsed PKGBUILDs\n    GIT--&gt;&gt;API: \nend\n\nloop Every 2 hours\n    DT-&gt;&gt;GHA: cron trigger\n    GHA-&gt;&gt;API: fetch TODO list\n    API--&gt;&gt;GHA: \n    GHA-&gt;&gt;GIT: fetch PKGBUILDs\n    GIT--&gt;&gt;GHA: \n    GHA-&gt;&gt;DT: fetch staging\n    DT--&gt;&gt;GHA: \n    GHA-&gt;&gt;GHA: build packages\n    GHA--&gt;&gt;DT: upload packages\nend\n\n    DEV-&gt;&gt;DT: fetch packages\n    DT--&gt;&gt;DEV: \n    DEV-&gt;&gt;DEV: sign packages\n    DEV-&gt;&gt;REPO: push to repo</code></pre>"},{"location":"dev/build-process/#security-considerations","title":"Security Considerations","text":"<p>Assuming changes to PKGBUILDs are properly reviewed, the pacman signature checking works, the upstream source is OK and all MSYS2 organization members are trusted we need to consider a bad actor controlling some part of the building process between the PKGBUILD getting changed and the package ending up signed in the pacman repo.</p> <p>A bad actor would need to get a package on the machine of the developer signing the package and adding it to the pacman repo. We take the following precautions:</p> <ul> <li>We only build packages automatically with GitHub Actions without third party   actions, excluding the official GitHub ones. We assume the GHA images and   official actions are safe.</li> <li>The download tool used by the person signing the package checks that the   binaries where uploaded by a restricted set of GitHub users or GHA.   We assume the bad actor doesn't have git push rights.</li> <li>Packages too large for GHA get built/signed by MSYS2 developers on their   machines. We assume the developer machines are safe.</li> <li>We enforce 2FA for the MSYS2 organization to make account takeovers of   existing MSYS2 developers harder.</li> </ul> <p>Feedback and ideas on how to improve this welcome.</p>"},{"location":"dev/keyring/","title":"MSYS2 Keyring","text":"<ul> <li>Repository: https://github.com/msys2/MSYS2-keyring</li> <li>Also see https://wiki.archlinux.org/index.php/Pacman/Package_signing</li> </ul>"},{"location":"dev/keyring/#master-keys","title":"Master Keys","text":"Master Key Full Fingerprint Owner 0xF40D263ECA25678A <code>D55E7A6D7CE9BA1587C0ACACF40D263ECA25678A</code> alexpux 0x9F418C233E652008 <code>B91BCF3303284BF90CC043CA9F418C233E652008</code> nacho 0xDA7EF2ABAEEA755C <code>9DD0D4217D75A33B896159E6DA7EF2ABAEEA755C</code> martell 0x790AE56A1D3CFDDC <code>6E8FEAFF9644F54EED90EEA0790AE56A1D3CFDDC</code> elieux 0x755B8182ACD22879 <code>69985C5EB351011C78DF7F6D755B8182ACD22879</code> lazka"},{"location":"dev/keyring/#developer-keys","title":"Developer Keys","text":"<p>Each of these keys is signed by at least three master keys.</p> Developer Key Full Fingerprint Owner 0x5F92EFC1A47D45A1 <code>AD351C50AE085775EB59333B5F92EFC1A47D45A1</code> alexpux 0x974C8BE49078F532 <code>87771331B3F1FF5263856A6D974C8BE49078F532</code> elieux 0xFA11531AA0AA7F57 <code>5F944B027F7FE2091985AA2EFA11531AA0AA7F57</code> lazka"},{"location":"dev/keyring/#master-key-signatures","title":"Master Key Signatures","text":"Developer Key Signed by alexpux alexpux, nacho, martell, lazka elieux elieux, alexpux, lazka lazka alexpux, lazka, elieux"},{"location":"dev/mirrors/","title":"Mirrors","text":"<p>Our main repo server is located in Germany and contains the pacman databases and packages, matching source packages and installers. The whole content of the mirror is regularly synced to multiple mirrors across the world.</p> <p>All these servers are registered with pacman under <code>/etc/pacman.d/mirrorlist.*</code>. The first URL in those lists is the primary mirror, all others will be used as a fallback. You can make another mirror the primary one by moving it to the top.</p> <p>In case you have problems with a particular mirror please let us know by filing an issue: https://github.com/msys2/msys2.github.io/issues</p>"},{"location":"dev/mirrors/#primary-server","title":"Primary Server","text":"Name URL Note repo.msys2.org HTTPS | RSYNC primary mirror.msys2.org HTTPS geo redirection service for Tier 1 mirrors"},{"location":"dev/mirrors/#tier-1-mirrors","title":"Tier 1 Mirrors","text":"<p>Requirements: Reliable, 1GBit/s+ with enough free bandwidth, rsync server support (*), HTTPS support, synced at least once per day from the primary server.</p> <p>Map: https://mirror.msys2.org/?mirrorstats</p> Name URLs Note mirror.umd.edu HTTPS | RSYNC website ftp.acc.umu.se HTTPS | RSYNC ftp-adm@acc.umu.se ftp.nluug.nl HTTPS | RSYNC ftp-admin@nluug.nl ftp.osuosl.org HTTPS | RSYNC hosting-request@osuosl.org mirror.internet.asn.au HTTPS | RSYNC peering@ix.asn.au mirror.selfnet.de HTTPS | RSYNC admin mirror.yandex.ru HTTPS | RSYNC - mirrors.dotsrc.org HTTPS | RSYNC staff@dotsrc.org mirrors.tuna.tsinghua.edu.cn HTTPS | RSYNC - mirrors.ustc.edu.cn HTTPS | RSYNC lug@ustc.edu.cn mirror.nju.edu.cn HTTPS | RSYNC issue mirrors.bfsu.edu.cn HTTPS | RSYNC issue mirrors.hit.edu.cn HTTPS | RSYNC issue mirror.clarkson.edu HTTPS | RSYNC issue quantum-mirror.hu HTTPS | RSYNC website fastmirror.pp.ua HTTPS | RSYNC website mirror.archlinux.tw HTTPS | RSYNC issue <p>(*) rsync is required by mirrorbits, which we use to auto-redirect users to a local mirror via mirror.msys2.org</p>"},{"location":"dev/mirrors/#tier-2-mirrors","title":"Tier 2 Mirrors","text":"<p>Requirements: Synced regularly.</p> Name URLs Note ftp.cc.uoc.gr HTTPS mirrors@cc.uoc.gr mirrors.bit.edu.cn HTTPS webmaster@bitnp.net mirror.jmu.edu HTTPS mirrormaster@jmu.edu mirrors.piconets.webwerks.in HTTPS mirrors@piconets.com mirrors.sjtug.sjtu.edu.cn HTTPS www2.futureware.at HTTPS Nick \u00d8stergaard mirrors.aliyun.com HTTPS ali-yum@alibaba-inc.com mirror.iscas.ac.cn HTTPS mirrors.cloud.tencent.com HTTPS petzhou@tencent.com mirror.ufro.cl HTTPS Jonathan Guti\u00e9rrez download.nus.edu.sg HTTPS download@nus.edu.sg"},{"location":"dev/mirrors/#adding-a-new-mirror","title":"Adding a New Mirror","text":"<p>The repository size is ~725 GiB (see https://mirror.jmu.edu/ for current stats) with the distribution of sizes like this:</p> <pre><code>  -1K: ~14000 files\n-100K:  ~3200 files\n  -1M:  ~5000 files\n -10M:  ~4000 files\n-100M:  ~1000 files\n  -1G:   ~200 files\n -10G:    ~20 files\n</code></pre> <p>You can use rsync to update your mirror using</p> <pre><code>rsync -rlptH --safe-links --delete-delay --delay-updates \\\n    rsync://repo.msys2.org/builds/ ./msys2\n</code></pre> <p>Our repository layout is compatible with Arch Linux, which means you can use the following script to sync everything more frequently and efficiently:</p> <p>https://gitlab.archlinux.org/archlinux/infrastructure/-/blob/master/roles/syncrepo/files/syncrepo-template.sh</p> <pre><code>source_url='rsync://repo.msys2.org/builds/'\nlastupdate_url='https://repo.msys2.org/lastupdate'\n</code></pre> <p>To register your mirror please open an issue here: https://github.com/msys2/msys2.github.io/issues</p>"},{"location":"dev/new-package/","title":"Creating a new Package","text":"<p>A package consists of a package recipe in the form of a <code>PKGBUILD</code> file. See the PKGBUILD file for glib as an example. To have your package included in the official repository it has to end up in the package git repository via a pull request \u2192 https://github.com/msys2/MINGW-packages/pulls</p>"},{"location":"dev/new-package/#things-to-consider-before-creating-a-pkgbuild-file","title":"Things to consider before creating a PKGBUILD file","text":"<ul> <li>Does the project you'd like to package support Windows and does it support   other compilers than MSVC?</li> <li>Is the project you'd like to package already in the repo?</li> <li>Are all the runtime and build dependencies of that project already in the   repo?</li> <li>Does building the project work in an MSYS2 environment?</li> <li>Is the project packaged in Arch Linux or in   the AUR, to help you as a reference for both the   build process and finding a package name?</li> </ul>"},{"location":"dev/new-package/#creating-a-new-pkgbuild-file","title":"Creating a new PKGBUILD file","text":"<p>Many projects are similar to build and package, so it's easiest to just copy an existing PKGBUILD file as a starting point. You can either look for a package with a similar build system and dependencies in our repository or use one of our <code>PKGBUILD</code> templates:</p> <ul> <li>CMake - git: PKGBUILD.CMake-git</li> <li>CMake - tarball: PKGBUILD.CMake-tarball</li> <li>Autotools - tarball: PKGBUILD.autotools-tarball</li> <li>Rust/Cargo - tarball: PKGBUILD.cargo-tarball</li> <li>Meson - tarball: PKGBUILD.meson-tarball</li> <li>Python - tarball: PKGBUILD.python</li> </ul> <p>After you have decided on a good starting point:</p> <ol> <li>Decide on a package name. If the project is already packaged in Arch Linux or    the AUR then we prefer the same name.</li> <li>Create a directory called <code>mingw-w64-&lt;package-name&gt;</code></li> <li>Move your <code>PKGBUILD</code> file into that directory.</li> <li>Fill out your <code>PKGBUILD</code> file<ul> <li>See https://wiki.archlinux.org/title/PKGBUILD for details on the format and   the meaning of variables and functions.</li> <li>See our Package Guidelines for how we expect   <code>PKGBUILD</code> files to be structured and how they should behave.</li> </ul> </li> <li>Run <code>updpkgsums</code> to update the source checksums in the <code>PKGBUILD</code> file.</li> <li>Build the package...</li> </ol>"},{"location":"dev/new-package/#building-the-package","title":"Building the package","text":"<p>Building a package requires a base set of build related packages to be installed first. This only needs to be done once:</p> <pre><code>pacman -S --needed base-devel\n</code></pre> <p>To build the package, start a shell in an environment you want to build for, change the working directory to the directory of the <code>PKGBUILD</code>, and run:</p> <pre><code>makepkg-mingw --cleanbuild --syncdeps --force --noconfirm\n</code></pre> <p>This will download all required build dependencies, build your package, and will result in a <code>*.pkg.tar.zst</code> package in the same directory, if nothing goes wrong.</p> <p>To install the package you can run:</p> <pre><code>pacman -U *.pkg.tar.zst\n</code></pre> <p><code>makepkg-mingw</code> has various other helpful options you can add:</p> <ul> <li><code>--install</code> - to install the built package right away</li> <li><code>--rmdeps</code> - to remove all packages again that it installed for building</li> <li><code>--help</code> - to see more options</li> </ul>"},{"location":"dev/new-package/#proposing-the-package-to-be-included-in-our-official-repository","title":"Proposing the package to be included in our official repository","text":"<p>Once you are pleased with your package and have tested it sufficiently you can create a pull request against our package repository \u2192 https://github.com/msys2/MINGW-packages/pulls</p> <p>Once the PR is opened, our CI system will try to build your package in a fresh and clean build environment and will also try to build it for all our supported target environments (mingw64, clang64, etc).</p> <p>There is a chance that this will uncover some issues in your package, such as unspecified build dependencies, or uncover errors in projects that build with gcc but not with clang for example. If that is the case you can try to fix the found issues or ask us for assistance.</p>"},{"location":"dev/new-package/#differences-compared-to-arch-linux","title":"Differences compared to Arch Linux","text":"<p>If you are already accustomed to building packages for Arch Linux, you might notice some differences despite us using the same tools:</p> <ul> <li>Our <code>PKGBUILD</code> files use environment variables such as <code>MINGW_PACKAGE_PREFIX</code>   and <code>MINGW_PREFIX</code> in various places so they can be used to build packages for   difference environments using the same <code>PKGBUILD</code> file.</li> <li>We use <code>makepkg-mingw</code> instead of <code>makepkg</code>. <code>makepkg-mingw</code> is just a small   wrapper around <code>makepkg</code> which sets up the right environment and also allows   building the same package multiple times for different environments in one go.</li> </ul>"},{"location":"dev/package-guidelines/","title":"Package Guidelines","text":""},{"location":"dev/package-guidelines/#applying-git-patches","title":"Applying git patches","text":"<p>Git patches should be applied in <code>prepare()</code>. Since the build system doesn't have a committer configured and we generally try to avoid changing the git history because that distorts the input for a later <code>pkgver()</code> call, we apply patches without committing:</p> <ul> <li>Use <code>git apply</code> to apply a git patch without creating a commit</li> <li>In case of a git checkout use <code>git cherry-pick --no-commit</code> to backport a commit without creating a commit.</li> </ul>"},{"location":"dev/package-guidelines/#release-signing-keys","title":"Release Signing Keys","text":""},{"location":"dev/package-guidelines/#what-to-do-when-a-new-release-is-signed-with-a-new-key","title":"What to do when a new release is signed with a new key?","text":"<p>Visit the upstream website or other official communication channels and verify that the new key is an official release signing key.</p> <p>While at it you can also verify that <code>validpgpkeys</code> does not contain inactive signing keys. If a key in <code>validpgpkeys</code> seems unused, either because the person upstream switched to a new key, or if the key isn't listed upstream anymore please remove it from <code>validpgpkeys</code>.</p>"},{"location":"dev/package-guidelines/#python-packages","title":"Python Packages","text":"<p>If possible we include \".pyc\" and \".opt-1.pyc\" for all .py files in all packages because:</p> <ul> <li>In case the package directory isn't writable to speed up the Python startup</li> <li>To avoid file conflicts when a package starts do create their own .pyc files while for the older version the user's Python created them at runtime.</li> </ul> <p>.pyc files contain the absolute path of their respective Python source file for things like stack traces. Since our packages are relocatable there is no \"right\" path to store, so we just use the \"unix\" path, so something like <code>/ucrt64/lib/python3.10/site-packages/foo.py</code>.</p> <p>To create such .pyc files in a PKGBUILD for packages which don't do it themselves you can use the following snippet:</p> <pre><code>MSYS2_ARG_CONV_EXCL=\"-p\" \\\n  python -m compileall -o 0 -o 1 -q -s\"${pkgdir}\" -p\"/\" \"${pkgdir}${MINGW_PREFIX}\"\n</code></pre>"},{"location":"dev/package-guidelines/#the-package-prefix-hack","title":"The package prefix (hack)","text":"<p>When looking at some of our package recipes you might have seen something like:</p> <pre><code>MSYS2_ARG_CONV_EXCL=\"--prefix=\" \\\n  meson \\\n    --prefix=\"${MINGW_PREFIX}\" \\\n    ...\n</code></pre> <p>which results in <code>meson --prefix=/mingw64 ...</code> being executed.</p> <p><code>/mingw64</code> in this case is the UNIX prefix where the package will be installed to and in addition is a valid Windows path (a drive relative path, so <code>C:\\mingw64</code>), so the native build tools will concatenate it with DESTDIR and copy things to the right place.</p> <p>In the native Windows world this path doesn't make much sense, as <code>C:\\mingw64</code> likely doesn't match where the software lives, but ideally all native Windows tools are relocatable and won't use the prefix at runtime anyway. And if they do and happen to call Cygwin tools then the prefix resolves to the correct path because the Cygwin root path is relocatable.</p>"},{"location":"dev/package-licensing/","title":"License Metadata","text":"<p>Software we package is always licensed and there are two places where the licenses are recorded in a package:</p> <ul> <li>The <code>license</code> array field in the package metadata, as specified in the   PKGBUILD file</li> <li>Copies of the license text contained in the package, usually under   <code>&lt;prefix&gt;/share/licenses/&lt;real-package-name&gt;/*</code>. In some cases packages install   their license files in different places though.</li> </ul>"},{"location":"dev/package-licensing/#guidelines-for-specifying-license-metadata","title":"Guidelines for Specifying License Metadata","text":""},{"location":"dev/package-licensing/#the-license-array-field","title":"The license array field","text":"<ul> <li>Values starting with <code>spdx:</code> are SPDX license   expressions.   Example: <code>('spdx:GPL-2.0-or-later')</code></li> <li>Multiple values starting with <code>spdx:</code> are treated as if they are combined with   <code>OR</code>. Example: <code>('spdx:LGPL-2.1-only', 'spdx:MPL-1.1')</code> is the same as   <code>('LGPL-2.1-only OR MPL-1.1')</code></li> <li>Mixing of spdx values and other values is undefined</li> <li>Values not starting with <code>spdx:</code> or starting with <code>custom:</code> follow the Arch   Linux rules.</li> <li>In case of a split package each package can have a different license field   depending on the package content. The global license field is inherited by   each split package but can be overridden there.</li> </ul>"},{"location":"dev/package-licensing/#the-license-text-files","title":"The license text files","text":"<p>In case the package provides one or more license text files, they can be installed to <code>&lt;prefix&gt;/share/licenses/&lt;real-package-name&gt;/*</code>. <code>real-package-name</code> is the package name without the environment specific prefix, so in case of <code>mingw-w64-ucrt-x86_64-meson</code> it is just <code>meson</code>. Example: <code>/ucrt64/share/licenses/meson/COPYING</code></p> <p>These guidelines are inspired by</p> <ul> <li>https://www.python.org/dev/peps/pep-0639/#advanced-example</li> <li>https://getcomposer.org/doc/04-schema.md#license</li> </ul>"},{"location":"dev/package-licensing/#differences-compared-to-arch-linux","title":"Differences compared to Arch Linux","text":"<p>See https://wiki.archlinux.org/title/PKGBUILD#license</p> <ul> <li>Arch Linux doesn't use SPDX identifiers, but manages its own license list in a   licenses package.   This list is not very exhaustive and is missing various variants of common licenses   such as <code>GPL-2.0-or-later</code> vs <code>GPL-2.0-only</code>.</li> <li>Everything else is prefixed with <code>custom:</code>, e.g. <code>custom:name of license</code>.</li> <li>It's unclear (does anyone know?) if multiple licenses mean that the package is   available under either license or you must comply with both licenses.</li> </ul> <p>Given the above shortcomings we use our own rules inspired by other packaging systems.</p>"},{"location":"dev/package-licensing/#faq","title":"FAQ","text":""},{"location":"dev/package-licensing/#the-package-includes-different-components-with-different-licenses-what-should-i-do","title":"The package includes different components with different licenses, what should I do?","text":"<p>Let's say the package source is licensed under <code>Apache-2.0</code>, there is a vendored library that is licenses under <code>MIT</code>, and there is documentation that is licensed under <code>CC-BY-4.0</code>.</p> <p>You can set the license field to <code>spdx:Apache-2.0 AND MIT AND CC-BY-4.0</code>.</p> <p>In case the documentation is split out into a separate package then you can use <code>spdx:Apache-2.0 AND MIT</code> for the main package and <code>spdx:CC-BY-4.0</code> for the documentation package.</p>"},{"location":"dev/package-licensing/#how-can-i-specify-a-custom-license-in-an-spdx-expression-that-is-not-on-the-spdx-license-list","title":"How can I specify a custom license in an SPDX expression that is not on the SPDX license list?","text":"<p>You can define your own license ID with the following format <code>LicenseRef-&lt;idstring&gt;</code> where <code>idstring</code> is allowed to contain <code>[A-Za-z0-9.-]</code>. For example: <code>LicenseRef-my-special-license</code></p>"},{"location":"dev/package-licensing/#the-projects-is-licensed-under-gpl-20-or-later-and-only-advertises-that-but-contains-mit-and-bsd-code-as-well-should-i-include-them-all","title":"The projects is licensed under <code>GPL-2.0-or-later</code> and only advertises that but contains <code>MIT</code> and <code>BSD</code> code as well. Should I include them all?","text":"<p>We can't be expected to hunt down every license in every file of every project. In case the project says it's <code>GPL-2.0-or-later</code> then it's fine to just use that.</p>"},{"location":"dev/pkgbuild/","title":"PKGBUILD","text":"<p>PKGBUILD is the Arch Linux package build description file, which we inherit by using pacman. See https://man.archlinux.org/man/PKGBUILD.5 for details on the format. We have some minor extensions to the format, which are documented here.</p>"},{"location":"dev/pkgbuild/#extra-metadata","title":"Extra Metadata","text":"<p>Variables starting with <code>msys2_</code> and <code>mingw_</code> can be used to add additional metadata to a package, which will be read and used by our tools. The following variables are recognized:</p> Variable Type Description <code>mingw_arch</code> array A list of MSYS2 environments the package is built for. Defaults to an empty list. <code>msys2_internal</code> boolean Whether the package is an internal or meta package and shouldn't be linked to external sources. Defaults to <code>false</code>. <code>msys2_references</code> mapping Maps the package to external resources, such as other package repositories. <code>msys2_changelog_url</code> string NEWS file in git or the GitHub releases page. In case there are multiple, the one that is more useful for packagers. <code>msys2_documentation_url</code> string URL to the documentation for the API, tools, etc., in case it's a different website than the homepage. <code>msys2_repository_url</code> string URL to the web view of the repository, e.g., on GitHub or GitLab. <code>msys2_issue_tracker_url</code> string URL to the bug tracker, mailing list archive, etc. <code>msys2_pgp_keys_url</code> string URL to a website containing which keys are used to sign releases. <p>For <code>msys2_references</code> the following keys are recognized:</p> <ul> <li><code>archlinux</code> - the Arch Linux package name: https://archlinux.org/packages/</li> <li><code>aur</code> - the AUR package name: https://aur.archlinux.org/packages</li> <li><code>cygwin</code> - the cygwin package name: https://cygwin.com/packages/src_package_list.html</li> <li><code>cygwin-mingw64</code> -   the cygwin package name for all packages starting with \"mingw64-x86_64-\",   minus that prefix: https://cygwin.com/packages/src_package_list.html</li> <li><code>pypi</code> - the PyPI project name: https://pypi.org/search/</li> </ul> <p>Defining a key without a value means there is no mapping and the package shouldn't be linked.</p> <p>The following datatypes are supported:</p> <ul> <li>string: <code>msys2_myvar=\"example\"</code> \ud83e\udc06 <code>{\"myvar\": \"example\"}</code></li> <li>array: Arrays of strings: <code>msys2_myvar=(\"example1\" \"example2\")</code> \ud83e\udc06 <code>{\"myvar\": [\"example1\", \"example2\"]}</code></li> <li>mapping: Mappings of strings to an optional string, separated by <code>\":\"</code>, values are   stripped: <code>msys2_myvar=(\"example1: value1\" \"example2\")</code> \ud83e\udc06 <code>{\"myvar\": {\"example1\": \"value1\", \"example2\": null}}</code></li> <li>boolean: either <code>true</code> or <code>false</code>: <code>msys2_myvar=true</code> \ud83e\udc06 <code>{\"myvar\": true}</code></li> </ul>"},{"location":"dev/python/","title":"Python","text":"<ul> <li>PKGBUILD: https://github.com/msys2/MINGW-packages/tree/master/mingw-w64-python</li> <li>Source: https://github.com/msys2-contrib/cpython-mingw</li> </ul>"},{"location":"dev/python/#major-version-upgrade-workflow","title":"Major Version Upgrade Workflow","text":"<ul> <li>Create a new branch at https://github.com/msys2-contrib/cpython-mingw for the new version</li> <li>Copy the existing PKGBUILD to a \"python3.x\" and set <code>_primary_python=no</code></li> <li>Test the new version (Windows 7 support?)</li> <li>Maybe wait for 3.x.1 / 2 for the initial issues to be ironed out</li> <li>Figure out which packages need to be rebuild:<ul> <li>Use https://github.com/jeremyd2019/package-grokker to detect dependencies on   the .dll</li> <li><code>pacman -Fyqx '/python3\\.9/' '.*\\.pyc'</code> to detect the remaining packages</li> </ul> </li> <li>Try to update packages that need to be rebuild to get potential Python related   fixes.</li> <li>Move the PKGBUILD over to <code>mingw-w64-python</code> and make it the default one and   rebuild all relevant packages</li> <li>Let autobuild handle the rest</li> </ul>"},{"location":"dev/update-package/","title":"Updating an existing Package","text":"<p>In case you are looking for packages which need to be updated have a look at our Outdated Packages page. To get a list of packages which are outdated and have potential security issues have a look at the Repology pages for msys2_mingw and msys2_msys2.</p>"},{"location":"dev/update-package/#updating-a-package","title":"Updating a Package","text":"<ul> <li>Fork the packages repository if you   haven't already and create a new branch for your update</li> <li>Look at the upstream changelog for potential update related information like   new dependencies, changes to build options, changes to the build system, etc.</li> <li>Update pkgver in the PKGBUILD and reset pkgrel back to 1</li> <li>Run <code>updpkgsums</code> in the PKGBUILD directory for updating the checksums of the   source files</li> <li>Run <code>makepkg-mingw --cleanbuild --syncdeps --force --install --noconfirm</code> to   build and install the new version</li> <li>Test the new version, if possible</li> <li>Commit and push your changes and open a pull request. Try to include some   brief information of your changes like why you added/removed patches, why you   added/removed new dependencies, why you changed the build options etc.</li> </ul> <p>If your lucky then this is all that's needed, but in some cases the new version might need some additional work:</p> <ul> <li>In case there are patches that no longer apply they have to be refreshed</li> <li>In case some patches are no longer needed in the new version they have to be   removed</li> <li>In case the release is signed by a new signing key the key has to be added to   the <code>validpgpkeys</code> array</li> <li>In case of major changes, like a build system switch, consider comparing the   old build result and the new build result for differences to avoid any   regressions. meld can be a   helpful tool for this.</li> <li>In case there are incompatible changes that might break reverse-dependencies   (DLL name changes, ABI breaks, etc.) bump the pkgrel of all reverse   dependencies and include them in your PR.</li> </ul> <p>After you have submitted your pull request, our CI system will try to build the package for all environments and do so some simple checks on it. After the update is reviewed and merged you can follow the build process on our Pending Updates status page.</p>"},{"location":"docs/autotools/","title":"Autotools","text":"<p>MSYS2 ships with multiple versions of autotools related tools such as autoconf and automake. To make things easier for developers we provide meta packages which depend on all the usual packages needed to re-configure an autotools based project:</p> <pre><code>pacman -S \"${MINGW_PACKAGE_PREFIX}-autotools\" # for mingw\npacman -S autotools # for msys\n</code></pre> <p>Since some projects depend on specific versions of automake and, in some cases, autoconf, we provide two wrappers which dynamically provide different versions using the same script:</p>"},{"location":"docs/autotools/#automake-wrapper","title":"automake wrapper","text":"<p>By default the automake wrapper will detect the right version based on existing generated files and things will just work. You can also force a different version via the <code>WANT_AUTOMAKE</code> env var, and the newest available version via <code>WANT_AUTOMAKE=latest</code>.</p> <pre><code>WANT_AUTOMAKE='1.15' autoreconf -fvi\n</code></pre>"},{"location":"docs/autotools/#autoconf-wrapper","title":"autoconf wrapper","text":"<p>By default the autoconf wrapper will detect the right version based on existing generated files and things will just work. You can also force a different version via the <code>WANT_AUTOCONF</code> env var, and the newest available version via <code>WANT_AUTOCONF=latest</code>.</p> <pre><code>WANT_AUTOCONF='2.69' autoreconf -fvi\n</code></pre> <p>These wrappers are developed by Gentoo Linux and are also used in Cygwin.</p>"},{"location":"docs/autotools/#known-issues","title":"Known Issues","text":"<p>Some projects require their configure scripts to be updated to make them build successfully:</p> <pre><code>$ pacman -S \"${MINGW_PACKAGE_PREFIX}-autotools\"\n$ autoreconf -fvi\n$ ./configure\n$ make\n...\n</code></pre> <p>This is due to some MSYS2 specific patches that have not been upstreamed yet or have not made it into upstream projects.</p>"},{"location":"docs/ci/","title":"Using MSYS2 in CI","text":""},{"location":"docs/ci/#github-actions-recommended","title":"Github Actions (recommended)","text":"<p>Assuming you use GitHub this is the easiest way to get going. We provide a GitHub Action which handles everything from installing the latest MSYS2, updating it and installing all the packages you need. All you have to do is to provide a BASH script that runs your code in the MSYS2 environment.</p> <p>1) Create a workflow file, for example <code>.github/workflows/msys2.yml</code>, see the GitHub docs for more details</p> <p>2) Paste the following into your workflow file:</p> <pre><code>name: MSYS2\non: [push, pull_request]\n\njobs:\n  msys2-ucrt64:\n    runs-on: windows-latest\n    defaults:\n      run:\n        shell: msys2 {0}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: msys2/setup-msys2@v2\n        with:\n          msystem: UCRT64\n          update: true\n          install: git mingw-w64-ucrt-x86_64-gcc\n      - name: CI-Build\n        run: |\n          echo 'Running in MSYS2!'\n          ./ci-build.sh\n</code></pre> <p>For more details on the 'msys2/setup-msys2' action and all the available options see https://github.com/marketplace/actions/setup-msys2</p>"},{"location":"docs/ci/#appveyor","title":"Appveyor","text":"<p>Appveyor provides a MSYS2 installation on all their images under <code>C:\\msys64</code>, see https://www.appveyor.com/docs/windows-images-software/</p> <p>Make sure to use the <code>Visual Studio 2019</code> image or newer, as the MSYS2 installation on older images is outdated and updating there no longer works.</p> <p>In case you want to update the MSYS2 installation and install packages you need to update MSYS2 first. For this you need to run the following commands:</p> <pre><code># Update MSYS2\nC:\\msys64\\usr\\bin\\bash -lc \"pacman --noconfirm -Syuu\"  # Core update (in case any core packages are outdated)\nC:\\msys64\\usr\\bin\\bash -lc \"pacman --noconfirm -Syuu\"  # Normal update\n\n# Then run your code\n$env:CHERE_INVOKING = 'yes'  # Preserve the current working directory\n$env:MSYSTEM = 'UCRT64'  # Start a 64 bit Mingw environment\nC:\\msys64\\usr\\bin\\bash -lc \"./ci-build.sh\"\n</code></pre>"},{"location":"docs/ci/#docker","title":"Docker","text":"<p>Install MSYS2 under <code>C:\\msys64</code> into a Windows based Docker image:</p> <pre><code># select as base image matching your host to get process isolation\nFROM mcr.microsoft.com/windows/servercore:2004\n\nSHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n\nRUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \\\n  Invoke-WebRequest -UseBasicParsing -uri \"https://github.com/msys2/msys2-installer/releases/download/nightly-x86_64/msys2-base-x86_64-latest.sfx.exe\" -OutFile msys2.exe; \\\n  .\\msys2.exe -y -oC:\\; \\\n  Remove-Item msys2.exe ; \\\n  function msys() { C:\\msys64\\usr\\bin\\bash.exe @('-lc') + @Args; } \\\n  msys ' '; \\\n  msys 'pacman --noconfirm -Syuu'; \\\n  msys 'pacman --noconfirm -Syuu'; \\\n  msys 'pacman --noconfirm -Scc';\n</code></pre>"},{"location":"docs/ci/#other-systems","title":"Other Systems","text":"<p>On systems that don't provide MSYS2 integration you need to install and update MSYS2 yourself.</p> <p>1) Download and install MSYS2. For CI systems we provide a self extracting     archive, so you don't need any additional tools.</p> <pre><code># Download the archive\n(New-Object System.Net.WebClient).DownloadFile('https://github.com/msys2/msys2-installer/releases/download/nightly-x86_64/msys2-base-x86_64-latest.sfx.exe', 'msys2.exe')\n.\\msys2.exe -y -oC:\\  # Extract to C:\\msys64\nRemove-Item msys2.exe  # Delete the archive again\n</code></pre> <p>2) Run MSYS2 for the first time and update it</p> <pre><code># Run for the first time\nC:\\msys64\\usr\\bin\\bash -lc ' '\n# Update MSYS2\nC:\\msys64\\usr\\bin\\bash -lc 'pacman --noconfirm -Syuu'  # Core update (in case any core packages are outdated)\nC:\\msys64\\usr\\bin\\bash -lc 'pacman --noconfirm -Syuu'  # Normal update\n</code></pre> <p>3) Run your code (<code>ci-build.sh</code> in this case)</p> <pre><code>$env:CHERE_INVOKING = 'yes'  # Preserve the current working directory\n$env:MSYSTEM = 'UCRT64'  # Start a 64 bit Mingw environment\nC:\\msys64\\usr\\bin\\bash -lc './ci-build.sh'\n</code></pre>"},{"location":"docs/ci/#faq","title":"FAQ","text":"<p>My CI system doesn't exit at the end of the run and hangs. What's wrong?</p> <p>In some cases CI systems will wait until all processes you have started have also ended, but the MSYS2 setup and update might spawn processes for gnupg etc. that will stay around in the background forever. To end them all you can run:</p> <pre><code>taskkill /F /FI \"MODULES eq msys-2.0.dll\"\n</code></pre> <p>MSYS2 fails to update on Appveyor with some \"key is unknown\" error. What's wrong?</p> <p>The MSYS2 installation on older Appveyor images hasn't been updated in years and is no longer supported. Either use the <code>Visual Studio 2019</code> image or newer, or install MSYS2 manually as described above.</p>"},{"location":"docs/cmake/","title":"Using CMake in MSYS2","text":""},{"location":"docs/cmake/#installing","title":"Installing","text":"<p>When building projects for Windows with CMake (as opposed to building projects that are going to run in MSYS2 posix emulation runtime) make sure to install the MinGW version of CMake, i.e. installing e.g. <code>mingw-w64-x86_64-cmake</code>.</p> <p>You also want to install a tool for actually doing the build. The current recommended default is Ninja, which you can install from the <code>mingw-w64-x86_64-ninja</code> package.</p> <p>(Other alternatives are <code>make</code> or <code>mingw-w64-x86_64-make</code>, for building with GNU Make running either as a MSYS2 or MinGW process.)</p>"},{"location":"docs/cmake/#building","title":"Building","text":"<p>When running the CMake configuration command, it's recommended to explicitly specify the desired build file generator with the <code>-G</code> option. MSYS2 provided CMake defaults to Ninja (but this is not the default in upstream CMake, so it's safest to explicitly specify it).</p> <p>Thus, to configure and build a CMake based project, you can run the following commands:</p> <pre><code>$ cmake -G Ninja &lt;path-to-source&gt; -DCMAKE_BUILD_TYPE=Release\n$ cmake --build .\n</code></pre> <p>The relevant generator alternatives are:</p> <ul> <li><code>-G Ninja</code></li> <li><code>-G \"MSYS Makefiles\"</code></li> <li><code>-G \"MinGW Makefiles\"</code></li> </ul> <p>If building by invoking <code>cmake --build</code>, the same command works for all generator choices. Alternatively, to build by directly invoking the build tool, you can call <code>ninja</code>, <code>make</code> or <code>mingw32-make</code> respectively for those three alternatives.</p>"},{"location":"docs/cmake/#examples","title":"Examples","text":"<p>For building projects with CMake in MSYS2 in Github Actions, see the CMake Example.</p>"},{"location":"docs/configuration/","title":"Configuration Locations","text":"<p>Cygwin packages, like openssh and git, follow the standard Unix conventions and use your <code>$HOME</code> or <code>$HOME/.config</code> directory for storing the user configuration and <code>/etc</code> for the system configuration.</p> <p>For native Windows programs the situation is a bit more complicated. For the user configuration some programs use the standard Windows paths, such as <code>%USERPROFILE%\\AppData\\Roaming</code>. In some cases native Windows programs are minimally ported from Unix and will write to <code>%USERPROFILE%\\.appname</code> or <code>%USERPROFILE%\\.config\\appname</code>, or they will prefer the <code>HOME</code> environment variable over <code>USERPROFILE</code> and store their configuration in <code>$HOME\\.appname</code> or <code>$HOME\\.config\\appname</code> like their Unix variants. For the system configuration some programs might store them alongside their other data files or in case they were ported from Unix they might follow the Unix layout and store things in <code>$MINGW_PREFIX/etc/appname</code></p>"},{"location":"docs/configuration/#faq","title":"FAQ","text":"<p>Can't all programs use the same location for their user configuration?</p> <p>While having two locations for configuration can be confusing we want native programs to follow Windows conventions and be independent from MSYS2. Also we don't want to change the behavior of programs compared to their upstream versions unless we have to.</p>"},{"location":"docs/cpp/","title":"C++","text":""},{"location":"docs/cpp/#known-issues","title":"Known Issues","text":"<p>The exception handling implementation used in the MINGW32 environment only works with a dynamically linked libgcc, so using <code>-static-libgcc</code> anywhere in your build will lead to broken exception handling (see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105507#c5). Other environments are not affected.</p>"},{"location":"docs/environments/","title":"Environments","text":"<p>MSYS2 comes with different environments and the first thing you have to decide is which one to use. The differences among the environments are mainly environment variables, default compilers/linkers, architecture, system libraries used etc. If you are unsure, go with UCRT64.</p> <p>The MSYS environment contains the unix-like/cygwin based tools, lives under <code>/usr</code> and is special in that it is always active. All the other environments inherit from the MSYS environment and add various things on top of it.</p> <p>For example, in the UCRT64 environment the <code>$PATH</code> variable starts with <code>/ucrt64/bin:/usr/bin</code> so you get all ucrt64 based tools as well as all msys tools.</p>"},{"location":"docs/environments/#overview","title":"Overview","text":"Name Prefix Toolchain Architecture C Library C++ Library MSYS <code>/usr</code> gcc x86_64 cygwin libstdc++ UCRT64 <code>/ucrt64</code> gcc x86_64 ucrt libstdc++ CLANG64 <code>/clang64</code> llvm x86_64 ucrt libc++ CLANGARM64 <code>/clangarm64</code> llvm aarch64 ucrt libc++ CLANG32 <code>/clang32</code> llvm i686 ucrt libc++ MINGW64 <code>/mingw64</code> gcc x86_64 msvcrt libstdc++ MINGW32 <code>/mingw32</code> gcc i686 msvcrt libstdc++ <p>The active environment is selected via the <code>MSYSTEM</code> environment variable. Setting <code>MSYSTEM</code> to <code>UCRT64</code> and starting a login shell will put you in that environment.</p>"},{"location":"docs/environments/#gcc-vs-llvmclang","title":"GCC vs LLVM/Clang","text":"<p>These are the default compilers/toolchains used for building all packages in the respective repositories.</p> <p>GCC based environments:</p> <ul> <li>Widely tested/used at this point</li> <li>Fortran support</li> <li>While there also exists a Clang package in the MINGW environments, that one   still uses the GNU linker and the GNU C++ library. In some cases Clang is used   to build packages as well there, in case upstream prefers Clang over GCC for   example.</li> </ul> <p>LLVM/Clang based environments:</p> <ul> <li>Only uses LLVM tools, LLD as a linker, LIBC++ as a C++ standard library</li> <li>Clang provides ASAN support</li> <li>Native support for TLS (Thread-local storage)</li> <li>LLD is faster than LD, but does not support all the features LD supports</li> <li>Some tools lack feature parity with equivalent GNU tools</li> <li>Supports ARM64/AArch64 architecture on Microsoft Windows 10</li> </ul>"},{"location":"docs/environments/#msvcrt-vs-ucrt","title":"MSVCRT vs UCRT","text":"<p>These are two variants of the C standard library on Microsoft Windows.</p> <p>MSVCRT (Microsoft Visual C++ Runtime) is available by default on all Microsoft Windows versions, but due to backwards compatibility issues is stuck in the past, not C99 compatible and is missing some features.</p> <ul> <li>It isn't C99 compatible, for example the printf() function family, but...</li> <li>mingw-w64 provides replacement functions to make things C99 compatible in many   cases</li> <li>It doesn't support the UTF-8 locale</li> <li>Binaries linked with MSVCRT should not be mixed with UCRT ones because the   internal structures and data types are different. (More strictly, object   files or static libraries built for different targets shouldn't be mixed.   DLLs built for different CRTs can be mixed as long as they don't share   CRT objects, e.g. <code>FILE*</code>, across DLL boundaries.) Same rule is applied for   MSVC compiled binaries because MSVC uses UCRT by default (if not changed).</li> <li>Works out of the box on every version of Microsoft Windows.</li> </ul> <p>UCRT (Universal C Runtime) is a newer version which is also used by Microsoft Visual Studio by default. It should work and behave as if the code was compiled with MSVC.</p> <ul> <li>Better compatibility with MSVC, both at build time and at run time.</li> <li>It only ships by default on Windows 10 and for older versions you have to   provide it yourself or depend on the user having it installed.</li> </ul>"},{"location":"docs/faq/","title":"FAQ","text":""},{"location":"docs/faq/#how-can-i-get-msys2-running-under-wine","title":"How can I get MSYS2 running under Wine?","text":"<p>Wine fails to run Cygwin binaries and as a result MSYS2 and Git for Windows, which are based on Cygwin. See the following bug reports for the current state of things:</p> <ul> <li>https://github.com/msys2/MSYS2-packages/issues/682</li> <li>https://github.com/git-for-windows/git/issues/3478</li> <li>https://bugs.winehq.org/show_bug.cgi?id=40528</li> </ul> <p>It might require fixes in both Wine and Cygwin to get resolved. If anyone makes some progress on this, let us know!</p>"},{"location":"docs/faq/#how-can-i-make-msys2pacman-trust-my-companys-custom-tls-ca-certificate","title":"How can I make MSYS2/pacman trust my company's custom TLS CA certificate","text":"<p>In case your computer is managed by an organization they might MITM all your TLS connections and install their own custom CA certificate onto your system so that MITM connections are still marked as secure. Because OpenSSL in MSYS2 currently doesn't integrate with the Windows system CA store, and thus doesn't know about your organization's custom certificates you have to add them and trust them manually.</p> <p>You might be affected if you see the following errors when using pacman, curl or similar:</p> <ul> <li><code>SSL certificate problem: unable to get local issuer certificate</code></li> <li><code>SSL certificate problem: self signed certificate in certificate chain</code></li> </ul> <p>First we need to get the certificates of your organization</p> <p>1) via Firefox:</p> <ul> <li>Open https://repo.msys2.org in Firefox (the connection should be marked as secure!)</li> <li>Press ctrl+i to open the page info</li> <li>Go to \"Security\" and click \"View Certificate\"</li> <li>Go through all tabs where the certificate belongs to your organization, scroll down and click on \"PEM (cert)\" to download the \"*.pem\" file</li> </ul> <p>2) or via Chrome/Chromium/Edge:</p> <p>See https://stackoverflow.com/a/70398349</p> <p>3) or by asking your IT department to give you the certificates.</p> <p>Now that we have the certificate files, we copy them into MSYS2 and register them:</p> <ul> <li>Open a MSYS2 shell</li> <li>Place the .pem/.cer files into <code>/etc/pki/ca-trust/source/anchors</code></li> <li>Run <code>update-ca-trust</code> (there is no output)</li> </ul> <p>Now TLS connections to the MSYS2 repo should work:</p> <pre><code>$ curl --fail --silent --show-error -I https://repo.msys2.org -o /dev/null &amp;&amp; echo \"OK!\"\nOK!\n</code></pre> <p>The certificates can be removed again by deleting the .pem/.cer files in <code>/etc/pki/ca-trust/source/anchors</code> and running <code>update-ca-trust</code> again.</p>"},{"location":"docs/faq/#how-long-are-old-packages-kept-on-repomsys2org","title":"How long are old packages kept on repo.msys2.org?","text":"<p>1.75 years after a package version leaves the pacman package database, it is removed from the server. This means that if you do not update the pacman DB for more than 1.75 years, the installation of packages may fail until you update.</p> <p>External projects that rely on specific package versions on the repo server are advised to mirror those packages if the above retention policy does not meet their needs.</p>"},{"location":"docs/faq/#what-does-magic-number-mismatch-detected-mean","title":"What does \"magic number mismatch detected\" mean?","text":"<p>msys2 is a fork of cygwin and uses a pinned memory address to allow coordination between different executables running in the same environment. This memory format is determined by a \"magic number\" header at the top of the pinned memory address to ensure that corrupted memory is not read. While having multiple copies of the msys2 dll running at the same time is not necessarily a problem, what is a problem is having multiple versions that write different versions to the same space (or if that pinned memory gets rebased and accessed in a wrong way).</p> <p>For this reason, the following scenarios can cause a address memory mismatch:</p> <ol> <li>Address randomization being turned on for the initial program or dll</li> <li>A program loading multiple versions of msys2 with mismatched magic numbers</li> <li>A program loading multiple versions of msys2 and forcing the dll to be address rebased</li> <li>A separate program loading msys2 in</li> </ol> <p>Since a lot of command line tools pack msys2 with them to provide a nice operating scenario then you may need to make sure that these are aligned correctly. For this reason, make sure to be using compatible versions of msys2 with other components</p>"},{"location":"docs/filesystem-paths/","title":"Filesystem Paths","text":"<p>Many of our build processes are made up of a mix of Cygwin tools (makepkg/bash for starters) and native Windows tools. When building things the paths of input and output files and directories are often communicated between them via process arguments or environment variables. The problem here is that those are in many cases not compatible:</p> <ul> <li><code>C:\\nope</code> is not a valid Unix path and <code>\\n</code> might make problems when being   interpreted as an escape sequence.</li> <li><code>C:/nope</code> is slightly better, because, while it's not a valid Unix path, if   it's just forwarded to some other Windows tools things might work out fine.</li> <li><code>/foo</code> is both a valid Windows path (drive relative path evaluating to   <code>C:\\foo</code> for example) and a valid Unix path, but resolves to a different path.   Again, if it's just forwarded to some other Unix tool then things might work   out fine.</li> <li><code>foo/bar.txt</code>just works, relative to the current working directory, while   <code>foo\\bar.txt</code> is only OK with native tools.</li> <li>Path lists, commonly used in environment variables like <code>FOO=/foo:/bar</code> also   will never work, since paths are separated by <code>;</code> on Windows and not <code>:</code>,   similarly <code>c:/foo</code> could be interpreted as a Unix path list containing <code>c</code> and   <code>/foo</code> when a path list is expected.</li> </ul> <p>The only solution here is to avoid mixing Unix/Cygwin and native tools outside of makepkg (preferred) or convert them when they get passed between the different programs. For the latter MSYS2 provides an automatic conversion that just works automatically in many cases.</p>"},{"location":"docs/filesystem-paths/#manual-unix-windows-path-conversion","title":"Manual Unix \u27f7 Windows Path Conversion","text":"<p>MSYS2 ships the Cygwin tool <code>cygpath</code> by default which allows converting paths between the Unix format, Windows format, and mixed format, see <code>cygpath --help</code> for details.</p> <pre><code>$ cygpath -u C:\\\\foo\n/c/foo\n$ cygpath -m /mingw64/bin\nC:/msys64/mingw64/bin\n$ cygpath -w /mingw64/bin\nC:\\msys64\\mingw64\\bin\n</code></pre>"},{"location":"docs/filesystem-paths/#automatic-unix-windows-path-conversion","title":"Automatic Unix \u27f6 Windows Path Conversion","text":""},{"location":"docs/filesystem-paths/#process-arguments","title":"Process Arguments","text":"<p>When calling native executables from the context of Cygwin then all the arguments that look like Unix paths will get auto converted to Windows. For example when calling native Python from the context of bash:</p> <pre><code>$ python3 -c \"import sys; print(sys.argv)\" --dir=/foo\n['-c', '--dir=C:/msys64/foo']\n$ python3 -c \"import sys; print(sys.argv)\" --dir=/foo:/bla\n['-c', '--dir=C:\\\\msys64\\\\foo;C:\\\\msys64\\\\bla']\n</code></pre> <p>While this is helpful in many cases it's also not perfect and in corner cases converts arguments that look like Unix paths while they are not, or detects lists of Unix paths where there are none. For these cases you can exclude certain arguments via the <code>MSYS2_ARG_CONV_EXCL</code> environment variable:</p> <pre><code>$ MSYS2_ARG_CONV_EXCL='--dir=' python3 -c \"import sys; print(sys.argv)\" --dir=/foo\n['-c', '--dir=/foo']\n</code></pre> <p><code>MSYS2_ARG_CONV_EXCL</code> can either be <code>*</code> to mean exclude everything, or a list of one or more arguments prefixes separated by <code>;</code>, like <code>MSYS2_ARG_CONV_EXCL=--dir=;--bla=;/test</code>. It matches the prefix against the whole argument string.</p>"},{"location":"docs/filesystem-paths/#environment-variables","title":"Environment Variables","text":"<p>Similar to process arguments, paths in environment variables get converted too:</p> <pre><code>$ MYVAR=/foo python3 -c \"import os; print(os.environ['MYVAR'])\"\nC:/msys64/foo\n$ MYVAR=/foo:/bar python3 -c \"import os; print(os.environ['MYVAR'])\"\nC:\\msys64\\foo;C:\\msys64\\bar\n</code></pre> <p>You can disable the conversion with <code>MSYS2_ENV_CONV_EXCL</code>:</p> <pre><code>$ MSYS2_ENV_CONV_EXCL='MYVAR' MYVAR=/foo python3 -c \"import os; print(os.environ['MYVAR'])\"\n/foo\n</code></pre> <p><code>MSYS2_ENV_CONV_EXCL</code> can either be <code>*</code> to mean exclude everything, or a list of one or more environment variable prefixes separated by <code>;</code>, like <code>MSYS2_ENV_CONV_EXCL=FOO;BAR;/test</code>. It matches the prefix against the following string <code>KEY=VALUE</code>.</p> <p>Cygwin special cases some environment variables that are known to be paths or path lists and does less guessing with them. For example <code>HOME</code> will never be interpreted as a path list even if it contains <code>:</code>.</p>"},{"location":"docs/filesystem-paths/#windows-unix-path-conversion","title":"Windows \u27f6 Unix Path Conversion","text":"<p>You might wonder why calling things like <code>ls C:/</code> might work and suspect that again auto conversion is used, but that's not the case:</p> <pre><code>$ /usr/bin/python3 -c \"import sys, os; print(sys.argv, os.listdir(sys.argv[1]))\" C:/\n['-c', 'C:/'] ['$Recycle.Bin', '$SysReset', ...]\n</code></pre> <p>Cygwin which provides the POSIX API will just forward the paths to the Windows API as is. This works as long as the tool does not try to interpret the path too much and just forwards it to the system API. If that doesn't work in your case you can use <code>cygpath</code>:</p> <pre><code>$ /usr/bin/python3 -c \"import sys, os; print(sys.argv, os.listdir(sys.argv[1]))\" \"$(cygpath -u C:/)\"\n['-c', '/c/'] ['$Recycle.Bin', '$SysReset', ...]\n</code></pre>"},{"location":"docs/git/","title":"Git","text":"<p>We currently only provide a cygwin based git, which only understands and outputs Unix paths and thus behaves slightly differently compared to \"Git for Windows\". It also is quite a bit slower, which is especially noticeable on larger repositories.</p> <pre><code>pacman -S git\n</code></pre>"},{"location":"docs/git/#faq","title":"FAQ","text":""},{"location":"docs/git/#why-is-there-no-mingw-based-git-in-msys2-despite-git-for-windows-being-based-on-msys2","title":"Why is there no MinGW based Git in MSYS2 despite \"Git for Windows\" being based on MSYS2?","text":"<p>The git-for-windows project maintains various patches on top of git itself as well as patches various MSYS2 packages to get the git test suite to pass on Windows and provide a complete and bug-free git experience. Our long term goal is to include their git build, but no one has started working on this yet.</p> <p>There exists a guide to install the official build into MSYS2: https://github.com/git-for-windows/git/wiki/Install-inside-MSYS2-proper but note that this setup is only supported on a best effort basis and any issues should be verified with the official git build before reporting them upstream.</p>"},{"location":"docs/git/#why-are-gitk-and-git-gui-not-working-in-the-msys-environment","title":"Why are \"gitk\" and \"git gui\" not working in the MSYS environment?","text":"<p>They depend on Tcl/Tk and we only provide mingw builds for those. In all environments besides MSYS they should work fine though.</p>"},{"location":"docs/git/#some-tool-i-use-fails-to-work-with-the-git-in-msys2-but-works-fine-with-the-official-one","title":"Some tool I use fails to work with the git in MSYS2, but works fine with the official one","text":"<p>One common issue with external tools integrating git, is that they get confused by Unix paths, for example when figuring out the project root path via <code>git rev-parse --show-toplevel</code>. This can be worked around by using <code>git rev-parse --show-prefix</code> instead which outputs a relative path from the root to the current working directory, which is both a valid Unix and Windows path. Or <code>git rev-parse --show-cdup</code> which outputs a relative path from the current working directory to the root, which is also a valid Unix and Windows path.</p> <p>If all fails you can <code>export GIT_DIR=/dev/null</code> to make git not find any repository at all, which usually makes tools skip any git related logic.</p>"},{"location":"docs/ides-editors/","title":"IDEs and Text Editors","text":""},{"location":"docs/ides-editors/#sublime-text","title":"Sublime Text","text":"<p>Sublime Text is a text and source code editor. It features syntax highlighting, code folding, terminal output window, and more. To add the MSYS2 terminal profile in Sublime Text, please follow these steps:</p> <ul> <li> <p>Install Terminus package using   Package Control.</p> </li> <li> <p>In the menu bar, select Preferences &gt; Package Settings &gt; Terminus &gt; Settings   option. This will open Terminus.sublime-settings file in separate Sublime Text   window with two panes.</p> </li> <li> <p>In the right pane, add the following configuration for UCRT64.</p> </li> <li> <p>Change the command options as usual to use other terminal environments. If the   Terminus.sublime-settings is not empty append the above section after others.</p> </li> </ul> <pre><code>{\n  \"shell_configs\": [\n    {\n      \"name\": \"UCRT64\",\n      \"cmd\": [\n        \"cmd.exe\",\n        \"/c\",\n        \"C:\\\\msys64\\\\msys2_shell.cmd -defterm -here -no-start -ucrt64\"\n      ],\n      \"env\": {},\n      \"enable\": true,\n      \"platforms\": [\"windows\"]\n    }\n  ]\n}\n</code></pre> <ul> <li>Now the UCRT64 environment can be opened like any other shell in Sublime Text.   Press Ctrl + Shift + P &gt; Terminus: List shells &gt; UCRT64 &gt; Open in tab or pane.</li> </ul>"},{"location":"docs/ides-editors/#visual-studio-code","title":"Visual Studio Code","text":"<p>Add these lines to your <code>settings.json</code>:</p> <pre><code>{\n    \"terminal.integrated.profiles.windows\": {\n        \"MSYS2 UCRT\": {\n            \"path\": \"cmd.exe\",\n            \"args\": [\n                \"/c\",\n                \"C:\\\\msys64\\\\msys2_shell.cmd -defterm -here -no-start -ucrt64\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Now the <code>MSYS2 UCRT</code> profile is available when launching a terminal.</p>"},{"location":"docs/installer/","title":"MSYS2 Installer","text":"<p>The MSYS2 installer can be used to set up an initial MSYS2 environment. For further updating pacman is used. See the updating guide for more information.</p> <p></p> <p>The installer comes in three variants:</p> <ul> <li><code>msys2-x86_64-.exe</code>: The GUI installer (see screenshot above)</li> <li><code>msys2-base-x86_64-*.sfx.exe</code>: Just the files in a self extracting archive (missing Windows integration like shortcuts, uninstall entry, but otherwise works the same)</li> <li><code>msys2-base-x86_64-*.tar.xz</code>: Same as <code>.sfx.exe</code> but as an XZ archive</li> </ul> <p>The installer executables and tarballs are hosted on GitHub as well as on the repo server. We also provide nightly builds.</p>"},{"location":"docs/installer/#cli-usage-examples","title":"CLI Usage Examples","text":"<p>The GUI installer utilizes the Qt Installer Framework which also offers CLI options for automation.</p> <p>Installing the GUI installer via the CLI to <code>C:\\msys64</code>:</p> <pre><code>.\\msys2-x86_64-latest.exe in --confirm-command --accept-messages --root C:/msys64\n</code></pre> <p>Uninstalling an existing installation in <code>C:\\msys64</code> via the CLI:</p> <pre><code>C:\\msys64\\uninstall.exe pr --confirm-command\n</code></pre> <p>Installing the self extracting archive to <code>C:\\msys64</code>:</p> <pre><code>.\\msys2-base-x86_64-latest.sfx.exe -y -oC:\\\n</code></pre>"},{"location":"docs/installer/#faq","title":"FAQ","text":""},{"location":"docs/installer/#whats-the-difference-between-the-installer-and-the-archives","title":"What's the difference between the installer and the archives?","text":"<p>The installer provides some additional features such as installing shortcuts, registering an uninstaller, a GUI for selecting the installation path and automatically running a login shell at the end to initialize the MSYS2 environment.</p> <p>If you unpack the archives and run a login shell once, you will get a functionally equivalent MSYS2 installation.</p>"},{"location":"docs/installer/#what-is-contained-in-the-installerarchives","title":"What is contained in the installer/archives?","text":"<p>It contains the base package and all its dependencies. You can list the contained packages using: <code>pactree base -lu | sort</code></p>"},{"location":"docs/installer/#how-can-i-verify-the-basic-integrity-of-the-downloaded-files","title":"How can I verify the basic integrity of the downloaded files?","text":"<p>You can download the expected checksum by appending <code>.sha256</code> to each download URL. You can verify that the downloaded file matches the checksum by computing the checksum either with Powershell:</p> <pre><code>(Get-FileHash -Algorithm SHA256 -Path .\\msys2-x86_64-20230526.exe).Hash.toLower()\n432dcc8b5cc7d5104a85b52df8b1e77cdf91018e102ac7aa998248637d636229\n</code></pre> <p>or with 7-Zip, if you have it installed:</p> <ul> <li>Right clicking on <code>msys2-x86_64-20230526.exe</code></li> <li>Go into the \"7-Zip\" and then \"CRC SHA\" sub menu, and finally click on \"SHA-256\"</li> <li>7-Zip will pop up a window containing the checksum</li> </ul> <p>Compare the result with the content of \"https://github.com/msys2/msys2-installer/releases/download/2023-05-26/msys2-x86_64-20230526.exe.sha256\" to verify that your local file matches the checksum.</p>"},{"location":"docs/installer/#how-can-i-verify-that-the-downloaded-files-were-generated-by-msys2-developers","title":"How can I verify that the downloaded files were generated by MSYS2 developers?","text":"<p>The installer is signed using the following key:</p> <p><code>0EBF 782C 5D53 F7E5 FB02  A667 46BD 761F 7A49 B0EC</code></p> <p>You can download the signature by appending a <code>.sig</code> to all download URLs.</p> <p>Verification example:</p> <pre><code>$ gpg --keyserver keyserver.ubuntu.com --recv \"0EBF 782C 5D53 F7E5 FB02  A667 46BD 761F 7A49 B0EC\"\ngpg: key 46BD761F7A49B0EC: public key \"Christoph Reiter &lt;reiter.christoph@gmail.com&gt;\" imported\ngpg: Total number processed: 1\ngpg:               imported: 1\n$ ls\nmsys2-x86_64-20230526.exe  msys2-x86_64-20230526.exe.sig\n$ gpg --verify msys2-x86_64-20230526.exe.sig\ngpg: assuming signed data in 'msys2-x86_64-20230526.exe'\ngpg: Signature made Fr 26 Mai 2023 11:46:54 CEST\ngpg:                using RSA key E0AA0F031DBD80FFBA57B06D5A62D0CAB6264964\ngpg: Good signature from \"Christoph Reiter &lt;reiter.christoph@gmail.com&gt;\" [unknown]\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: 0EBF 782C 5D53 F7E5 FB02  A667 46BD 761F 7A49 B0EC\n     Subkey fingerprint: E0AA 0F03 1DBD 80FF BA57  B06D 5A62 D0CA B626 4964\n</code></pre> <p>For the signature to be valid, gnupg has to print \"Good signature\" and the primary fingerprint shown has to match <code>0EBF 782C 5D53 F7E5 FB02  A667 46BD 761F 7A49 B0EC</code>.</p>"},{"location":"docs/installer/#microsoft-defender-smartscreen-prevents-me-from-running-the-installer","title":"Microsoft Defender SmartScreen prevents me from running the installer","text":"<p>Depending on the age of the installer release and how many people have already used it successfully, Windows will show a SmartScreen warning, preventing you from running the installer.</p> <p>You can skip this warning by first clicking on \"More info\" and then on \"Run anyway\".</p> <p></p>"},{"location":"docs/package-management-faq/","title":"FAQ","text":""},{"location":"docs/package-management-faq/#what-to-do-when-pacman-is-telling-me-there-are-conflicts-in-the-file-system","title":"What to do when Pacman is telling me there are conflicts in the file system?","text":"<p>This indicates that Pacman isn't sure it is safe to overwrite some files.  This sometimes happens during regular package updates, but could also happen if you installed some software manually (<code>make install</code>, <code>npm install npm -g</code> etc.).  To continue with the operation, pass <code>--overwrite &lt;conflicting_file_path&gt;</code> to the Pacman command line.  For other options, see the Arch Linux FAQ entry about Pacman file conflicts.</p>"},{"location":"docs/package-management-tips/","title":"Tips and Tricks","text":"<p>A list of useful small guides related to package management. See lots more on the Arch Linux wiki.</p>"},{"location":"docs/package-management-tips/#show-the-license-information-of-a-package","title":"Show the license information of a package","text":"<p>To list the license of an installed package you can run:</p> <pre><code>$ pacman -Qi meson | grep '^Licenses'\nLicenses        : Apache 2\n</code></pre> <p>To list the license of a package in the sync database you can run:</p> <pre><code>$ pacman -Si meson | grep '^Licenses'\nLicenses        : Apache 2\n</code></pre> <p>For the exact meaning of the license string see License Metadata.</p> <p>To list all license files installed by a package in the recommended location:</p> <pre><code>$ pacman -Ql meson | grep -E \"/share/licenses/.+/.+\"\nmeson /usr/share/licenses/meson/COPYING\n</code></pre> <p>Note that not every package includes the license text as a file, nor puts it in this specific recommended location.</p>"},{"location":"docs/package-management-tips/#listing-the-content-of-a-package","title":"Listing the content of a package","text":"<p>If you would like to know what has been installed as a part of a specific package use the following command:</p> <p><code>pacman -Ql &lt;name of the package&gt;</code></p> <p>Example:</p> <p><code>$ pacman -Ql mingw-w64-x86_64-pugixml</code></p> <pre><code>mingw-w64-x86_64-pugixml /mingw64/\nmingw-w64-x86_64-pugixml /mingw64/bin/\nmingw-w64-x86_64-pugixml /mingw64/bin/libpugixml.dll\nmingw-w64-x86_64-pugixml /mingw64/include/\nmingw-w64-x86_64-pugixml /mingw64/include/pugixml-1.8/\nmingw-w64-x86_64-pugixml /mingw64/include/pugixml-1.8/pugiconfig.hpp\nmingw-w64-x86_64-pugixml /mingw64/include/pugixml-1.8/pugixml.hpp\nmingw-w64-x86_64-pugixml /mingw64/lib/\nmingw-w64-x86_64-pugixml /mingw64/lib/cmake/\nmingw-w64-x86_64-pugixml /mingw64/lib/cmake/pugixml/\nmingw-w64-x86_64-pugixml /mingw64/lib/cmake/pugixml/pugixml-config-noconfig.cmake\nmingw-w64-x86_64-pugixml /mingw64/lib/cmake/pugixml/pugixml-config.cmake\nmingw-w64-x86_64-pugixml /mingw64/lib/pkgconfig/\nmingw-w64-x86_64-pugixml /mingw64/lib/pkgconfig/pugixml.pc\nmingw-w64-x86_64-pugixml /mingw64/lib/pugixml-1.8/\nmingw-w64-x86_64-pugixml /mingw64/lib/pugixml-1.8/libpugixml.dll.a\n</code></pre> <p>As you can see the package contains:</p> <ul> <li>a binary executable library file (libpugixml.dll),</li> <li>a static library (libpugixml.dll.a),</li> <li>2 header files (pugixml.hpp, pugiconfig.hpp),</li> <li>2 cmake files,</li> <li>and a PKGCONFIG file (pugixml.pc).</li> </ul>"},{"location":"docs/package-management/","title":"Package Management","text":""},{"location":"docs/package-management/#package-repositories","title":"Package repositories","text":"<p>The MSYS2 software distribution uses a port of <code>pacman</code> (known from Arch Linux) to manage (install, remove and update) binary packages and also to build those packages in the first place.</p> <p>Packages in MSYS2 work like packages in popular Linux distributions. A package is an archive containing a piece of software. This normally means executable files, runtime libraries, data, shared and static link libraries, header files, config files, and manual pages. Packages also contain metadata, such as the software's name, description of its purpose, version number, vendor, checksum, and a list of dependencies necessary for the software to run properly. Upon installation, the files contained are extracted into your MSYS2 installation directory and the metadata are stored in a local database.</p> <p>There are 6 package repositories, the \"classical\" ones msys2, mingw32, and mingw64 and the newer ucrt64, clang32, and clang64. The packages in msys2 are named just like on a Linux distribution, the packages in the others are prefixed by either <code>mingw-w64-i686-</code> for 32-bit packages, or <code>mingw-w64-x86_64-</code> for 64-bit packages with a secondary prefix <code>clang</code> or <code>ucrt</code> where applicable. For more details about those see 'Environments' and 'Package Naming'.</p>"},{"location":"docs/package-management/#finding-a-package","title":"Finding a package","text":"<p>If you want to find a specific package in the repository (and that package can or cannot be installed on your machine) you can use the following command:</p> <p><code>pacman -Ss &lt;name or part of the name of the package&gt;</code></p> <p>Example:</p> <p><code>$ pacman -Ss openjp</code></p> <pre><code>mingw32/mingw-w64-i686-openjpeg 1.5.2-7\n    An open source JPEG 2000 codec (mingw-w64)\nmingw32/mingw-w64-i686-openjpeg2 2.1.0-7\n    An open source JPEG 2000 codec (mingw-w64)\nmingw64/mingw-w64-x86_64-openjpeg 1.5.2-7\n    An open source JPEG 2000 codec (mingw-w64)\nmingw64/mingw-w64-x86_64-openjpeg2 2.1.0-7 [installed]\n    An open source JPEG 2000 codec (mingw-w64)\n</code></pre> <p>As you can see the <code>mingw-w64-x86_64-openjpeg2</code> package is installed, while the <code>mingw-w64-x86_64-openjpeg</code> package is not installed.</p> <p>If you would like to search only among the packages which has been already installed, use the following command:</p> <p><code>pacman -Qs &lt;name or part of the name of the package&gt;</code></p>"},{"location":"docs/package-management/#installing-a-package","title":"Installing a package","text":"<p>If you want to install a package, use the following command:</p> <p><code>pacman -S &lt;name of the package&gt;</code></p> <p>If the package has dependencies which are not installed, <code>pacman</code> will ask you whether you would like to install the dependencies in the first place.</p> <p><code>pacman -S</code> also accepts virtual package names and package group names. Virtual package names can be often encountered with packages built from Git, e.g. <code>msys2-launcher-git</code> can be installed by requesting <code>msys-launcher</code>. Package groups simplify installation of related packages, e.g. install <code>base-devel</code> to get basic development tools. Please note that neither of those are real packages, so the commands below won't accept these names and you need to use the real package names instead.</p>"},{"location":"docs/package-management/#uninstalling-a-package","title":"Uninstalling a package","text":"<p>The following command will remove a package (but not its dependencies nor any files produced by running it):</p> <p><code>pacman -R &lt;name of the package&gt;</code></p>"},{"location":"docs/package-management/#installing-a-specific-version-of-a-package-or-a-stand-alone-packages","title":"Installing a specific version of a package or a stand-alone packages","text":"<p>Older (or pre-release) versions of packages can be installed directly from the package archive (<code>.tar.zst</code> or <code>.tar.xz</code>). The data store for the repositories contains older versions of packages, but beware that you might need to recursively find correct versions of dependencies for the desired package. Once downloaded, the package can be installed like this:</p> <p><code>pacman -U &lt;packagefile.tar.zst&gt;</code></p> <p>or</p> <p><code>pacman -U &lt;packagefile.tar.xz&gt;</code></p>"},{"location":"docs/package-management/#finding-dependencies-of-a-package","title":"Finding dependencies of a package","text":"<p>You can use <code>pactree</code> to figure out which packages are needed to make a package working properly:</p> <p><code>$ pactree mingw-w64-x86_64-gettext</code></p> <pre><code>mingw-w64-x86_64-gettext\n\u251c\u2500mingw-w64-x86_64-expat\n\u251c\u2500mingw-w64-x86_64-gcc-libs\n\u2502 \u251c\u2500mingw-w64-x86_64-gmp\n\u2502 \u251c\u2500mingw-w64-x86_64-libwinpthread-git provides mingw-w64-x86_64-libwinpthread\n\u2502 \u2514\u2500mingw-w64-x86_64-gcc-libgfortran\n\u2502   \u2514\u2500mingw-w64-x86_64-gcc-libs\n\u2514\u2500mingw-w64-x86_64-libiconv\n</code></pre> <p>Alternatively you can use <code>pacman -Qi</code> to get the list of direct dependencies of a package:</p> <p><code>$ pacman -Qi mingw-w64-x86_64-gettext</code></p> <pre><code>Name            : mingw-w64-x86_64-gettext\nVersion         : 0.19.7-1\nDescription     : GNU internationalization library (mingw-w64)\n[...]\nDepends On      : mingw-w64-x86_64-expat  mingw-w64-x86_64-gcc-libs\n                  mingw-w64-x86_64-libiconv\n</code></pre>"},{"location":"docs/package-management/#finding-out-which-package-a-file-belongs-to","title":"Finding out which package a file belongs to","text":"<p>Use the following command to trace a file back to its owning package:</p> <p><code>pacman -Qo &lt;full file path&gt;</code></p> <p>Note that this operation only compares the file paths, so proper capitalization and the <code>.exe</code> suffix (if applicable) is required. Also note that this works only on installed packages, it will not scan the whole package repositories.</p>"},{"location":"docs/package-management/#finding-which-package-will-install-the-file-you-need","title":"Finding which package will install the file you need","text":"<p>The two recommended tools that can scan a repository and find packages that contain specific files are <code>pacman -F</code> and <code>pkgfile</code>. Below are examples of <code>pacman -F</code> usage:</p> <p>Call <code>pacman -Fy</code> to update your package database. To find an exact match, call <code>pacman -F &lt;filename&gt;</code> (don't include the path in the filename). To find a substring match, call <code>pacman -Fx &lt;filename&gt;</code>.</p> <p>Note that this operation only compares the file paths, so proper capitalization and the <code>.exe</code> suffix (if applicable) is required.</p>"},{"location":"docs/package-management/#resources","title":"Resources","text":"<ul> <li>Pacman on ArchWiki</li> <li>Pacman tips on ArchWiki</li> </ul>"},{"location":"docs/package-naming/","title":"Package Naming","text":""},{"location":"docs/package-naming/#overview","title":"Overview","text":"<p>The following table lists the packages according to their environment, see 'Environments' for general information on these. When installing packages, see  'Package Management', you'll commonly use the full name including the package prefix as outlined below.</p> Name [^1] Package prefix [^2] MSYS None MINGW64 <code>mingw-w64-x86_64-</code> UCRT64 <code>mingw-w64-ucrt-x86_64-</code> CLANG64 <code>mingw-w64-clang-x86_64-</code> MINGW32 <code>mingw-w64-i686-</code> CLANG32 <code>mingw-w64-clang-i686-</code> CLANGARM64 <code>mingw-w64-clang-aarch64-</code> <p>[^1]: environment variable <code>MSYSTEM</code>  [^2]: environment variable <code>MINGW_PACKAGE_PREFIX</code></p>"},{"location":"docs/package-naming/#avoiding-writing-long-package-names","title":"Avoiding writing long package names","text":"<p>Use <code>pacboy</code> to install mingw packages without having to type the long package names (install <code>pacboy</code> first using <code>pacman -S pactoys</code> if necessary).  Examples:</p> <p><code>pacboy</code> installs the listed packages for one or more environments. The selection of environments for each package is controlled by appending suffixes on the package name.</p> <p>In particular, adding the <code>:p</code> suffix installs the package for the current environment only.</p> <p>If no suffix is given, the selection of environments depends on what environment you're currently in - e.g. in a <code>mingw64</code> environment, it currently defaults to installing the package for both <code>mingw32</code> and <code>mingw64</code>.</p> <p>See the output of <code>pacboy help</code> for the list of suffixes: <pre><code>$ pacboy help\n\n    Pacboy 2016.6.24\n    Copyright (C) 2015, 2016 Renato Silva\n    Licensed under BSD\n\n    This is a pacman wrapper for MSYS2 which handles the package prefixes\n    automatically, and provides human-friendly commands for common tasks.\n\n    Usage:\n        pacboy [command] [arguments]\n        Arguments will be passed to pacman after translation:\n\n        For 64-bit MSYS2 shell:\n            name:i means i686-only\n            name:x means x86_64-only\n            name:z means clang-i686-only\n            name:c means clang-x86_64-only\n            name:u means ucrt-x86_64-only\n            name:a means clang-aarch64-only\n            name:p means MINGW_PACKAGE_PREFIX-only\n\n        For MSYS shell:\n            name:m means mingw-w64\n            name:l means mingw-w64-clang\n\n        For all shells:\n            name: disables any translation for name\n            repository::name means repository/name\n</code></pre></p> <p>Here are examples of using the <code>:x</code>, <code>:i</code> and <code>:m</code> suffixes for installing packages for the <code>mingw64</code>, <code>mingw32</code> and both environments: <pre><code>$ pacboy -S x265:x\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (1) mingw-w64-x86_64-x265-2.3-1\n\nTotal Download Size:    0.97 MiB\nTotal Installed Size:  20.72 MiB\n\n:: Proceed with installation? [Y/n]\n</code></pre> <pre><code>$ pacboy -S x265:i\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (1) mingw-w64-i686-x265-2.3-1\n\nTotal Download Size:    0.97 MiB\nTotal Installed Size:  11.37 MiB\n\n:: Proceed with installation? [Y/n]\n</code></pre> <pre><code>$ pacboy -S x265:m\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (2) mingw-w64-i686-x265-2.3-1  mingw-w64-x86_64-x265-2.3-1\n\nTotal Download Size:    0.97 MiB\nTotal Installed Size:  32.09 MiB\n\n:: Proceed with installation? [Y/n]\n</code></pre></p>"},{"location":"docs/pkgconfig/","title":"pkg-config","text":"<p>We default to pkgconf as our pkg-config implementation. This page lists some Windows specific topics/issues/challenges for working with pkg-config on Windows.</p>"},{"location":"docs/pkgconfig/#environment-variables","title":"Environment Variables","text":"<p>By default, the MSYS2 shells set the following environment variables with paths for the active environment to support pkgconf:</p> <ul> <li><code>PKG_CONFIG_PATH</code> - e.g. <code>/ucrt64/lib/pkgconfig:/ucrt64/share/pkgconfig</code></li> <li><code>PKG_CONFIG_SYSTEM_INCLUDE_PATH</code> - e.g. <code>/ucrt64/include</code></li> <li><code>PKG_CONFIG_SYSTEM_LIBRARY_PATH</code> - e.g. <code>/ucrt64/lib</code></li> </ul>"},{"location":"docs/pkgconfig/#prefix-relocation","title":"Prefix / Relocation","text":"<p>The first few lines of a .pc file usually look something like this:</p> <pre><code>prefix=/ucrt64\nincludedir=${prefix}/include\nlibdir=${prefix}/lib\n</code></pre> <p>As you can see <code>/ucrt64</code> is not a proper Windows path, but that's not a problem because by default <code>prefix</code> will be ignored, or rather re-defined by pkgconf/pkg-config based on the location of the .pc file itself. It will strip off <code>/&lt;...&gt;/pkgconfig</code> from the directory of the <code>.pc</code> file and use the resulting path as the new <code>prefix</code> (as documented here, which is sightly outdated as the second parent doesn't have to be <code>(lib|share)</code> but can be anything)</p> <p>So if the file is at <code>C:/msys64/ucrt64/lib/pkgconfig/glib-2.0.pc</code> it will take the directory <code>C:/msys64/ucrt64/lib/pkgconfig</code>, then strip of the last two parts, leading to <code>C:/msys64/ucrt64</code> and use that as the new prefix. This way you will get the right output independent of where MSYS2 is installed. You can disable this feature by passing <code>--dont-define-prefix</code> to pkgconf if wanted.</p> <p>Relocation depends on all other variables being relative to <code>prefix</code> by using <code>${prefix}</code> like in the example above. But some projects use absolute paths and in theory don't support relocation, which looks something like:</p> <pre><code>prefix=/ucrt64\nincludedir=/ucrt64/include\nlibdir=/ucrt64/lib\n</code></pre> <p>Luckily both pkg-config and pkgconf include a hack which replace all values that start with the value of <code>prefix</code> with <code>${prefix}</code>, so <code>/ucrt64/include</code> becomes <code>${prefix}/include</code>, making them relocatable anyway. So, despite <code>prefix</code> normally being ignored it might still be useful for such broken <code>.pc</code> files. Ideally all projects would only use relative paths, as absolute paths can also lead to problems on other platforms, see https://www.bassi.io/articles/2018/03/15/pkg-config-and-paths/.</p> <p>The above relocation logic sadly breaks down when you install the <code>.pc</code> into a different custom location, like <code>/lib/mylib-1.2/pkgconfig</code> as it will derive the wrong <code>prefix</code> value for them. See https://github.com/pkgconf/pkgconf/issues/286 for a more detailed summary of the problem. The only workaround there is to patch the <code>.pc</code> file with the wrong prefix in mind, like in this example: https://github.com/msys2/MINGW-packages/blob/9d4a713ce27c363a0ec63877775e229e7e4f36cb/mingw-w64-ffmpeg4.4/PKGBUILD#L215-L217</p>"},{"location":"docs/pkgconfig/#syntax-paths-escaping","title":"Syntax, Paths &amp; Escaping","text":"<p>pkg-config values can be dumped as is into a Unix shell, so if you want to use backslashes or spaces you need to escape them with <code>\\</code>.  So for example:</p> <pre><code>mypath=C:\\\\my\\ path\\ with\\ spaces\\\\file.txt\n</code></pre> <p>Since this is rather uncommon on Unix systems and tools might not expect it, it's recommended to avoid spaces in paths and use forward slashes instead of backslashes instead. Ideally both should work though.</p>"},{"location":"docs/pkgconfig/#cflagsprivate-static-libraries","title":"Cflags.private / Static Libraries","text":"<p>pkgconf, unlike pkg-config, supports an additional field called <code>Cflags.private</code> which is especially relevant on Windows.</p> <p>Many projects require that you define a specific C macro when statically linking against it on Windows, something like <code>-DMYLIB_STATIC</code>, or they define a macro via <code>Cflags</code> and require that you unset it when linking statically like <code>-UMYLIB_DLL</code>.</p> <p><code>Cflags.private</code> allows you to add extra CFLAGS that are only emitted via <code>--cflags</code> when <code>--static</code> is passed, making static builds work automatically.</p> <pre><code>$ pkgconf --cflags libxml-2.0\n-IC:/msys64/ucrt64/include/libxml2\n$ pkgconf --cflags --static libxml-2.0\n-IC:/msys64/ucrt64/include/libxml2 -DLIBXML_STATIC\n$ pkgconf --cflags x264\n-DX264_API_IMPORTS\n$ pkgconf --cflags --static x264\n-DX264_API_IMPORTS -UX264_API_IMPORTS\n</code></pre>"},{"location":"docs/python/","title":"Python","text":"<p>Since the official CPython implementation doesn't support building with GCC/Clang on Windows and has its own Windows specific directory layout, we maintain a friendly fork of CPython at https://github.com/msys2-contrib/cpython-mingw/</p> <p>Some differences/features compared to the official Windows CPython:</p> <ul> <li>In an active MSYS2 environment <code>os.sep</code> and <code>os.altsep</code> are switched to make relative paths more compatible with Unix tools that don't understand Windows paths. Outside of an active MSYS2 environment it behaves normally though.</li> <li><code>sys.path</code> uses the Unix directory layout, see <code>python -m site</code></li> <li>Virtual environments also work with bash: <code>python -m venv _venv</code>, <code>source _venv/bin/activate</code> and so on.</li> <li>When building against the limited API only defining <code>Py_LIMITED_API</code> isn't enough, you also have to explicitly link against <code>python3</code> instead of <code>python3.y</code>.</li> </ul>"},{"location":"docs/python/#portability","title":"Portability","text":"<p>As long as you don't hardcode/assume platform specific values and paths and always use things like <code>os.sep</code>, do path operations with <code>os.path</code> or <code>pathlib</code> and derive Python installation related paths and configuration from the <code>sysconfig</code> module then your Python code should work just like with the official Windows CPython installation.</p> <p>If for some reason you still need to detect our fork you can check for it as follows:</p> <pre><code>import os\nimport sysconfig\n\nif os.name == \"nt\" and sysconfig.get_platform().startswith(\"mingw\"):\n    print(\"cpython-mingw detected!\")\n</code></pre>"},{"location":"docs/python/#known-issues","title":"Known issues","text":"<ul> <li>C extensions are not compatible with the official CPython, which means pip can't use binary wheels from PyPI and packages have to be build when installing them.</li> <li>Some C extensions don't build out of the box since they don't expect non-MSVC on Windows. In some cases we provide patched versions in our repo.</li> <li>setuptools &gt;= 60.0 is currently incompatible with MSYS2. You can set <code>export SETUPTOOLS_USE_DISTUTILS=stdlib</code> to work around the issue. We are currently working on restoring compatibility.</li> </ul>"},{"location":"docs/repos-mirrors/","title":"Repositories and Mirrors","text":""},{"location":"docs/repos-mirrors/#active-environments","title":"Active environments","text":"<p>The package manager uses only environments that are configured under <code>/etc/pacman.conf</code>. You may add/uncomment/remove/comment those as needed:</p> <pre><code># always include msys!\n[msys]\nInclude = /etc/pacman.d/mirrorlist.msys\n\n[mingw32]\nInclude = /etc/pacman.d/mirrorlist.mingw\n\n[mingw64]\nInclude = /etc/pacman.d/mirrorlist.mingw\n\n[ucrt64]\nInclude = /etc/pacman.d/mirrorlist.mingw\n\n[clang64]\nInclude = /etc/pacman.d/mirrorlist.mingw\n\n[clang32]\nInclude = /etc/pacman.d/mirrorlist.mingw\n\n[clangarm64]\nInclude = /etc/pacman.d/mirrorlist.mingw\n</code></pre> <p>For more details about how to install packages see 'Package Management'.</p> <p>To launch an environment either use the wrapper executables like <code>ucrt64.exe</code> or call <code>msys2_shell.cmd</code> with either the matching parameter like <code>msys2_shell.cmd -clang64</code> or by setting <code>MSYSTEM</code>.</p>"},{"location":"docs/terminals/","title":"Terminals","text":""},{"location":"docs/terminals/#mintty","title":"Mintty","text":"<p>Mintty is the default terminal application in MSYS2 and is included in the installer. We also include some custom Mintty integration by providing separate launchers with corresponding .ini configuration files (msys2{.exe,.ini}/ucrt64{.exe,.ini}/...) for all the MSYS2 environments, so you can easily configure your environments and pin the launchers to your Windows taskbar.</p> <p>See https://github.com/msys2/msys2-launcher and https://mintty.github.io for more details.</p>"},{"location":"docs/terminals/#windows-terminal","title":"Windows Terminal","text":"<p>The new Windows Terminal application, which by default supports cmd, powershell and WSL can also be extended to support a MSYS2 shell.</p> <ul> <li>Get it via the Windows app store if you don't have   it installed already.</li> <li>In the tab dropdown menu select \"Settings\" which opens a code editor showing   a JSON configuration file.</li> <li>Insert the example profiles shown below under the <code>profiles</code> key. Note that   the examples assume that you have MSYS2 installed under <code>C:\\msys64</code>.</li> <li>You can make one of the MSYS2 profiles the default by setting the <code>defaultProfile</code>   key to the <code>guid</code> value of one of the profile entries.</li> </ul> <p>For more info on the different profile settings see https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-settings </p> <pre><code>// This makes UCRT64 the default shell\n\"defaultProfile\": \"{17da3cac-b318-431e-8a3e-7fcdefe6d114}\",\n\"profiles\": {\n  \"list\":\n  [\n    // ...\n    {\n      \"guid\": \"{17da3cac-b318-431e-8a3e-7fcdefe6d114}\",\n      \"name\": \"UCRT64 / MSYS2\",\n      \"commandline\": \"C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64\",\n      \"startingDirectory\": \"C:/msys64/home/%USERNAME%\",\n      \"icon\": \"C:/msys64/ucrt64.ico\",\n      \"font\": \n      {\n        \"face\": \"Lucida Console\",\n        \"size\": 9\n      }\n    },\n    {\n      \"guid\": \"{71160544-14d8-4194-af25-d05feeac7233}\",\n      \"name\": \"MSYS / MSYS2\",\n      \"commandline\": \"C:/msys64/msys2_shell.cmd -defterm -here -no-start -msys\",\n      \"startingDirectory\": \"C:/msys64/home/%USERNAME%\",\n      \"icon\": \"C:/msys64/msys2.ico\",\n      \"font\": \n      {\n        \"face\": \"Lucida Console\",\n        \"size\": 9\n      }\n    },\n    // ...\n  ]\n}\n</code></pre> <ul> <li>The <code>commandline</code> in that profile will launch bash shell by default. To change   default login shell, install the corresponding package for that shell and append   <code>-shell</code> option with the command line. For example,</li> <li>To set <code>fish</code> shell as default:     <pre><code>\"commandline\": \"C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell fish\"\n</code></pre></li> <li>To set <code>zsh</code> shell as default:     <pre><code>\"commandline\": \"C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell zsh\"\n</code></pre></li> </ul>"},{"location":"docs/terminals/#konsole","title":"Konsole","text":"<p>Konsole is a powerful and customizable terminal emulator made by KDE. MSYS2 provides it as a mingw package. To use it with MSYS2, first install the appropriate package and create a new profile with the following steps.</p> <ul> <li>In the Konsole window menu bar, select \"Settings\" &gt; \"Create New Profile...\".</li> <li>Select it as a default profile to always open msys2 environment at start.</li> <li>Add profile name and following command.</li> </ul> <pre><code>C:\\\\msys64\\\\msys2_shell.cmd -defterm -here -no-start -ucrt64\n</code></pre> <ul> <li>Now close and restart Konsole.</li> </ul>"},{"location":"docs/updating/","title":"Updating MSYS2","text":"<p>After you have installed MSYS2 via the installer or other means, you need to continue updating it with the built-in <code>pacman</code> tool. MSYS2 is a rolling release distribution and only supports full system upgrades, which means there are frequent minor and major updates to various packages and you can only update all packages at once.</p> <p>To update all packages run the following command:</p> <pre><code>$ pacman -Suy\n:: Synchronizing package databases...\n mingw32 is up to date\n mingw64 is up to date\n ucrt64 is up to date\n clang32 is up to date\n clang64 is up to date\n msys is up to date\n:: Starting core system upgrade...\n there is nothing to do\n:: Starting full system upgrade...\n there is nothing to do\n</code></pre> <p>In some cases, certain core packages will get updated and pacman will prompt you to close all terminals:</p> <pre><code>:: To complete this update all MSYS2 processes including this terminal will be closed.\n   Confirm to proceed [Y/n]\n</code></pre> <p>After confirming you need to start a new terminal and run the update again (<code>pacman -Suy</code>) to update the remaining non-core packages.</p>"},{"location":"docs/updating/#optional-maintenance-tasks","title":"Optional Maintenance Tasks","text":""},{"location":"docs/updating/#pruning-the-package-cache","title":"Pruning the package cache","text":"<p><code>pacman</code> keeps all packages it downloads under <code>/var/cache/pacman/pkg/</code>. To free up some space by removing old packages run:</p> <pre><code>$ paccache -r\n==&gt; finished: 5 packages removed (disk space saved: 49.05 MiB)\n</code></pre>"},{"location":"docs/updating/#managing-configuration-file-backups","title":"Managing configuration file backups","text":"<p>When you have modified a global configuration file of a package (under <code>/etc</code> for example) and the package is about to be removed or updated then pacman will avoid deleting your changes. The <code>pacdiff</code> tool can then be used to merge your configuration file with the default state again.</p> <p>1) In case a new package version with some changed configuration gets installed, which would discard your changes, pacman will leave the existing file alone and create a <code>&lt;filename&gt;.pacnew</code> with the new configuration instead:</p> <pre><code>warning: /etc/myconfig.conf installed as /etc/pacman.d/myconfig.conf.pacnew\n</code></pre> <p>You can run <code>pacdiff</code> which searches for such <code>.pacnew</code> files and will ask you how it should deal with them:</p> <pre><code>$ pacdiff\n==&gt; pacnew file found for /etc/myconfig.conf\n:: (V)iew, (M)erge, (S)kip, (R)emove pacnew, (O)verwrite with pacnew, (Q)uit: [v/m/s/r/o/q]\n</code></pre> <p>2) In case the configuration file is part of a package which gets uninstalled it will save a copy as <code>&lt;filename&gt;.pacsave</code> instead of deleting it:</p> <pre><code>warning: /etc/myconfig.conf saved as /etc/myconfig.conf.pacsave\n</code></pre> <p>If you later on install the package again you can run <code>pacdiff</code> to restore your original changes:</p> <pre><code>$ pacdiff\n==&gt; pacsave file found for /etc/myconfig.conf\n:: (V)iew, (M)erge, (S)kip, (R)emove pacsave, (O)verwrite with pacsave, (Q)uit: [v/m/s/r/o/q]\n</code></pre>"},{"location":"docs/updating/#pruning-unsupported-packages","title":"Pruning unsupported packages","text":"<p>In some cases we decide to drop packages from the repositories, for example because they are outdated, unmaintained or have been replaced by a better alternative. If you've installed them previously then they will stay installed but wont get updated anymore. To find such packages you can run:</p> <pre><code>$ pacman -Qm\n</code></pre> <p>It might be a good idea to remove them, or look for alternatives if you still need them.</p>"},{"location":"docs/updating/#potential-issues","title":"Potential Issues","text":"<p>If you haven't updated MSYS2 for more than half a year then you could end up in a state where an update would require a new or updated package maintainer's signature key but you haven't gotten it through an update yet. This will lead to pacman failing to verify the package or database signatures:</p> <pre><code>$ pacman -S lftp\n[...]\nerror: lftp: signature from \"Some MSYS2 Maintainer &lt;some.msys2.maintainer@gmail.com&gt;\" is unknown trust\n:: File /var/cache/pacman/pkg/lftp-4.9.2-3-x86_64.pkg.tar.zst is corrupted (invalid or corrupted package (PGP signature)).\nDo you want to delete it? [Y/n]\n</code></pre> <p>To get back to a working state you can run <code>pacman-key --refresh-keys</code>, which updates the package maintainer keys you already have installed.</p> <p>In case that doesn't help because a new key is required, you can do a partial upgrade of the keyring to get the missing key, followed by a full upgrade: <code>pacman -Sy msys2-keyring; pacman -Suy</code></p>"},{"location":"docs/what-is-msys2/","title":"What is MSYS2?","text":"<p>MSYS2 isn't \"one tool to rule them all\", but tries to focus on what it's good at. It provides a native build environment, based on open source software, and makes you feel right at home when you are already comfortable with Linux. There are good reasons to use multiple different environments and tools for different tasks on Windows.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-other-projects","title":"MSYS2 vs Other Projects","text":"<p>In case you'd like to see more comparisons or feel that they could be improved please let us know.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-wsl","title":"MSYS2 vs WSL","text":"<p>MSYS2 allows you to build native Windows programs, while with WSL you can only cross compile them which makes things more complicated. If you are just looking for Linux CLI tools, or want to build software that ends up on a Linux server anyway then WSL is the better choice.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-chocolatey","title":"MSYS2 vs Chocolatey","text":"<p>Chocolatey mainly bundles already built (open and closed source) software and makes it easy to install/update them. In MSYS2 on the other hand all packages are built from source and you can easily reproduce the builds on your machine. Chocolatey packages have the advantage that the bundled installers usually have better Windows integration, in that they set up file associations, shortcuts, etc. and because they are not built from source there are also lots of packages for closed source software like Visual Studio etc. that would be hard to manage/update otherwise.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-cygwin","title":"MSYS2 vs Cygwin","text":"<p>The unixy tools in MSYS2 are directly based on Cygwin, so there is some overlap there. While Cygwin focuses on building Unix software on Windows as is, MSYS2 focuses on building native software built against the Windows APIs.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-arch-linux","title":"MSYS2 vs Arch Linux","text":"<p>MSYS2 and Arch Linux share the package manager and all that comes with it, like build definitions, rules for how to package things, how updates work, how packages are signed, how packages are shipped, the rolling release nature and so on. By re-using this functionality and concepts we can focus on the actual packages and profit from the experience and work of Arch Linux developers. Users already familiar with Arch Linux will also have an easier time getting started.</p>"},{"location":"docs/what-is-msys2/#msys2-vs-scoop","title":"MSYS2 vs Scoop","text":"<p>Due to lack of experience with scoop see their comparison page:</p> <ul> <li>https://github.com/lukesampson/scoop/wiki/Chocolatey-Comparison</li> <li>https://github.com/lukesampson/scoop/wiki/Cygwin-and-MSYS-Comparison</li> </ul>"},{"location":"docs/who-is-using-msys2/","title":"Who Is Using MSYS2?","text":"<ul> <li>RubyInstaller2 uses MSYS2 to build Ruby for Windows in CI and as build environment for gems with C extensions.</li> <li>Gaphor uses MSYS2 for its Windows releases and for CI</li> <li>Git for Windows is based on MSYS2</li> <li>Quod Libet uses MSYS2 for its Windows build and for CI</li> <li>HDL/MINGW-packages uses MSYS2 for building and testing open source Electronic Design Automation (EDA) tools.</li> <li>ghdl/ghdl uses MSYS2 for building, packaging and testing GHDL.<ul> <li>ghdl/setup-ghdl-ci uses setup-msys2 for users to run GHDL on GitHub Actions' Windows environments.</li> <li>ghdl/extended-tests uses setup-msys2 and setup-ghdl-ci for testing third-party projects with GHDL on GitHub Actions' Windows environments.</li> </ul> </li> <li>gtkwave/gtkwave uses MSYS2 for building and packaging GTKWave.</li> <li>steveicarus/iverilog uses MSYS2 for building, packaging and testing Icarus Verilog.</li> <li>trabucayre/openFPGALoader uses MSYS2 for building, packaging and testing openFPGALoader.</li> <li>azonenberg/scopehal-apps uses MSYS2 for building libscopehal, glscopeclient and other client applications for libscopehal.</li> <li>Serial-Studio/Serial-Studio uses MSYS2 for building and testing Serial Studio.</li> <li>VUnit/vunit uses MSYS2 for testing VUnit.</li> <li>ImPPG uses MSYS2 for its Windows releases.</li> <li>Inkscape uses MSYS2 for its Windows releases and for CI (Documentation)</li> <li>KeePassXC uses MSYS2 for building and running KeePassXC password manager.</li> <li>Media-autobuild_suite uses MSYS2 for automatically building FFmpeg and other media related tools</li> <li>Nuwen's MinGW Build uses MSYS2 to build the files.</li> <li>OpenModelica uses MSYS2 for building the OpenModelica tools and compiling the generated simulation code on Windows.</li> <li>Paperwork uses MSYS2 for its Windows releases and for CI (Documentation)</li> <li>The R Project build system rtools40 is based on MSYS2 icw/ a custom repository of mingw packages (all statically linked).</li> <li>Spatial Model Editor uses MSYS2 for its Windows releases and for CI</li> <li>UrusStudio Installer uses MSYS2 for building and running Urus Studio IDE and URUS System.</li> <li>Webots uses MSYS2 to build Webots on Windows and for CI.</li> <li>Xournal++ uses MSYS2 for its Windows releases and for CI (Documentation).</li> <li>Neovim uses MSYS2 for its Windows building and running  (Documentation).</li> <li>darktable uses MSYS2 for its Windows releases and for CI (Documentation)</li> <li>Mesh2HRTF uses MSYS2 for its Windows NumCalc binaries (Documentation).</li> <li>PVSnesLib uses MSYS2 to build ROMs on Windows</li> </ul> <p>Feel free to add your project to this list!</p>"},{"location":"docs/windows_support/","title":"Supported Windows Versions and Hardware","text":"<p>We try to cater to two different types of users for our pre-built packages:</p> <ul> <li>Developers using MSYS2 directly, who usually want the latest software and tend to use newer hardware and keep their Windows up to date.</li> <li>End users, who use bundled applications containing pre-built packages from the MSYS2 repository. They can use very outdated Windows versions on very outdated hardware.</li> </ul> <p>In some cases we can't please both groups at the same time, so we have to find compromises.</p>"},{"location":"docs/windows_support/#msys-packages-the-installer","title":"Msys Packages &amp; the Installer","text":"<p>This includes the unixy environment and the GUI installer.</p> <p>Required Windows version: 64bit Windows 8.1 / Windows Server 2012 R2</p>"},{"location":"docs/windows_support/#mingw-packages","title":"Mingw Packages","text":"<p>This includes all packages that don't depend on Cygwin.</p> <p>Targeted Windows version (*): Windows 8.1+</p> <p>(*) If possible, depending on the upstream support. In some cases we can delay dropping support by staying on older versions/branches longer, or patching them, but that is not always practical or desirable.</p>"},{"location":"docs/windows_support/#supported-hardware","title":"Supported Hardware","text":"<p>We try to follow the minimum hardware requirements of the Windows versions we support.</p>"},{"location":"docs/windows_support/#additional-resources","title":"Additional Resources","text":"<ul> <li>Windows 7 Support Dates</li> <li>Windows 8 Support Dates</li> <li>Windows 8.1 Support Dates</li> <li>Windows 10 Support Dates</li> <li>Windows 11 Support Dates</li> </ul>"},{"location":"wiki/Creating-Packages/","title":"Creating Packages","text":"<p>The MSYS2 software distribution uses a port of Pacman (known from Arch Linux) to safely install, remove and update binary packages and also to build those packages in the first place.</p>"},{"location":"wiki/Creating-Packages/#general-information","title":"General information","text":"<p>There are 3 package repositories, msys, mingw32, and mingw64. msys software (from the msys repository) is software that depends on <code>msys-2.0.dll</code> and is very similar to Cygwin software (which is a POSIX emulation layer for Windows). Native Windows software (from this project's perspective) is software that doesn't depend on <code>msys-2.0.dll</code>, and links dynamically to the highly compatible <code>msvcrt.dll</code>.</p> <p>In this document, to attempt to avoid confusion, MSYS2 refers to the software distribution while msys refers to the repository, the packages in that repository and the software in those packages that link to <code>msys-2.0.dll</code>.</p>"},{"location":"wiki/Creating-Packages/#package-recipes","title":"Package recipes","text":"<p>Packages are built from programmatic recipes to ensure builds are reproducible. A recipe is a set of files which describe how to build, package and install a given piece of software; these are often specific to MSYS2.</p> <p>In the simplest form it is a single file named <code>PKGBUILD</code>, which contains metadata for the package, a specification where the source for the given software can be found, and a few lines of code which that takes the source and builds the final software from it. For more complex cases it also contains install scripts or a number of patch files which are needed to be applied on the released version of the upstream software in order to be able to compile and work in the given environment.</p> <p>Typically, each recipe is in its own directory. The directory is also used when building as a working place by default.</p>"},{"location":"wiki/Creating-Packages/#pkgbuild","title":"PKGBUILD","text":"<p>Use 2 spaces for indentation: <code>expand -t 2 PKGBUILD &gt; PKGBUILD.new &amp;&amp; mv PKGBUILD.new PKGBUILD</code></p> <p>A PKGBUILD is a bash script defining variables and functions that are then used by the build system to create the package. The PKGBUILD manpage and the PKGBUILD wikipage on ArchWiki are good sources to read about all the details of PKGBUILDs. The mingw PKGBUILDs are loosely based on the mingw-w64 cross-compilation packages guidelines in Arch Linux. If you don't want to read all that just yet, just read some existing PKGBUILDs; the purpose of most parts should be obvious.</p>"},{"location":"wiki/Creating-Packages/#patch-files","title":"Patch files","text":"<p>When creating a patch file, you can use the following naming convention for its name: <code>###-target-Purpose.patch</code></p> <p>Where</p> <ul> <li><code>###</code> a sequence number, starting from 001</li> <li><code>target</code>, is the package name and version (separated by a hyphen) for which the patch was first created</li> <li><code>[Purpose]</code> describes what the patch is fixing or improving</li> </ul>"},{"location":"wiki/Creating-Packages/#building","title":"Building","text":"<p>The actual build and packaging is done by running <code>makepkg</code> or <code>makepkg-mingw</code>. The former is used to build msys packages and the latter for mingw packages. To learn more, read the makepkg manpage and the makepkg wikipage on ArchWiki. When building either msys or native software, you should use the MSYS shell, not the MINGW{32,64} shells.</p> <p>The process happens in multiple phases:</p> <ul> <li>download, verify and extract - the package sources are downloaded if necessary, checked against checksums and PGP signatures if specified, and extracted into a working directory (<code>src</code> by default)</li> <li><code>prepare()</code> - using this function, the packager can specify what should happen with the sources before the actual build; apply patches and source modifications here</li> <li><code>build()</code> - this function contains commands to run the build tool(s), e.g. <code>./configure</code> and <code>make</code></li> <li><code>check()</code> - an optional step to check the build products by e.g. running the software's test suite</li> <li><code>package()</code> - this function is provided with a temporary directory, where it should put the final contents of the package using e.g. <code>make install</code></li> <li>tidy, archive and sign - the package contents are scanned for some issues, tidied up and packaged into the final <code>.tar.zst</code> with an optional signature in <code>.tar.zst.sig</code></li> </ul> <p>The makepkg tool takes arguments allowing you to turn off some phases or some checks. The typical usage is <code>makepkg -sCLf</code> for a full build and <code>makepkg -RdLf</code> for a \"re-package\". Re-packaging is useful when the process failed in <code>package()</code> and you don't want to run the long build part again. <code>makepkg-mingw</code> takes the same arguments.</p>"},{"location":"wiki/Creating-Packages/#re-building-a-package","title":"Re-building a package","text":"<p>To get you started, you can try just re-building an existing package. This may also be helpful if you need to diagnose an issue and need the debugging symbols.</p> <p>An example of fetching the msys repository source, building and then installing a package from it is:</p> <pre><code>git clone \"https://github.com/msys2/MSYS2-packages\"\ncd MSYS2-packages/flex\nmakepkg -sCLf\npacman -U flex-*.pkg.tar.zst\n</code></pre> <p>An example of fetching the mingw repository source, building and then installing a package from it is:</p> <pre><code>git clone \"https://github.com/msys2/MINGW-packages\"\ncd MINGW-packages/mingw-w64-python3\nmakepkg-mingw -sCLf\npacman -U mingw-w64-*-python3-*-any.pkg.tar.zst\n</code></pre>"},{"location":"wiki/Creating-Packages/#a-new-package-from-start-to-finish","title":"A new package from start to finish","text":"<p>Please do not create pull requests for PKGBUILDs that just repackage binary releases from other projects. This is contrary to the goals of MSYS2. If the software cannot be built for some reason then try to fix the cause of that.</p> <ol> <li>Decide which subsystem to target (msys or mingw)</li> <li>Build the software in the target subsystem</li> <li>Test the functionality</li> <li>Create patches if necessary and repeat</li> <li>Prepare a recipe</li> <li>Build the package</li> <li>Install the package locally</li> <li>Test the installed package</li> <li>Modify the recipe if necessary and repeat</li> <li>Commit the new package to the target repository (on your own GitHub account)</li> <li>Send a pull request to merge the new recipe into the official repository</li> <li>Check CI results, reviews and comments</li> <li>Fix issues if necessary and repeat</li> <li>Offer your fixes to the software's developers (upstream)</li> </ol> <p>The steps above describe an intuitive process of going from the idea of creating a package to making it available to you and others using <code>pacman</code>. You can of course customize the process to suit you and your situation.</p> <p>Once you are familiar with the process, we recommend creating recipes and using <code>makepkg</code> straight away for all packages. It's a great way to record your build steps in a reproducible way, which is not only useful for you, but also for other people when asked for help with the builds.</p>"},{"location":"wiki/Creating-Packages/#which-subsystem","title":"Which subsystem?","text":"<p>In MSYS2 there are 2 types of packages:</p> <ul> <li>msys packages - these run on the emulation layer and are typically POSIX-only programs</li> <li>mingw packages - these run natively just like any other Windows program</li> </ul> <p>You should think of these two systems as separate where msys packages should generally only be build dependencies of mingw packages. You also can't link a mingw program against an msys library.</p> <p>This means you first need to decide which subsystem (and which repository) is the right one for your new package. The set of things that belong to the msys subsystem is pretty small:</p> <ul> <li>essential POSIX stuff: <code>filesystem</code>, <code>msys2-runtime</code>, ...</li> <li>the native toolchain: <code>gcc</code>, <code>binutils</code>, <code>gdb</code>, ...</li> <li>supporting programs that are hard to port to Windows: <code>pacman</code>, <code>bash</code>, <code>automake</code>, <code>make</code>, ...</li> <li>programs for bridging the gap: <code>mintty</code>, <code>winpty</code>, ...</li> <li>supporting programs, even though they're portable: <code>python</code>, <code>man</code>, <code>vim</code>, <code>git</code>, ...</li> <li>carefully chosen useful tools: <code>mc</code>, <code>ssh</code>, <code>rsync</code>, <code>lftp</code>, ...</li> <li>dependencies of these packages</li> </ul> <p>In other words, if a program is needed to build native software, but is itself hard to port, it can be made into an msys package. Anything else needs to be done as a mingw package or vetted individually.</p>"},{"location":"wiki/Creating-Packages/#build-software","title":"Build software","text":"<p>In order to be able to compile a software or build a package you need to install basic packages by installing <code>base-devel</code>, as the MSYS2 install does not contain build tools.</p> <p>If you don't install the required package, building might fail with unexpected errors.</p> <p>Note that -- contrary to what you might expect -- <code>base-devel</code> doesn't contain <code>gcc</code> nor <code>binutils</code>.</p>"},{"location":"wiki/Creating-Packages/#test-software","title":"Test software","text":"<p>Check that the software does what it should. Try its test suite.</p>"},{"location":"wiki/Creating-Packages/#patch-software","title":"Patch software","text":"<p>If the software doesn't work straight away or doesn't even build, you'll probably need to pass some arguments to the build scripts or modify (patch) its build system, its source code, its definitions files etc. Such patches will be stored as files alongside the PKGBUILD.</p> <p>This part is very specific to each software and may require searching the Internet, talking to the software's developers or support team, talking to us etc. The Porting wikipage may help with some common issues. While it is probably okay to make quick (monkey-)patches that fix the software for our use case (and possibly break it for every other), is it better to make proper surgical-precision patches and attempt to have them accepted by the software developer (\"upstream\").</p>"},{"location":"wiki/Creating-Packages/#recipe","title":"Recipe","text":"<p>Create a <code>PKGBUILD</code> describing all the steps necessary to build and package the software, including any patches or additional files. Make sure the follow the style and ideas of other recipes if applicable. A good strategy is to find some existing working recipes that use the same build system as your software does and use them as a template for your recipe. You can also take inspiration from an official Arch Linux (or unofficial AUR) recipe for your software.</p>"},{"location":"wiki/Creating-Packages/#build-package","title":"Build package","text":"<p>Run the makepkg command (<code>makepkg</code> or <code>makepkg-mingw</code>) on your recipe.</p> <p><code>makepkg-mingw</code> is essentially a wrapper that does a few checks, sets up the correct environments and runs <code>makepkg</code> twice, once for mingw32 and once for mingw64. If you want to build just for one architecture (e.g. if you're on 32-bit Windows), you'll need to define <code>MINGW_ARCH</code> in the environment, with either <code>mingw32</code> or <code>mingw64</code> as the value, for example:</p> <pre><code>MINGW_ARCH=mingw64 makepkg-mingw -sCLf\n</code></pre> <p>... or you could export it from <code>~/.profile</code> so it's set up automatically:</p> <pre><code>export MINGW_ARCH=mingw64\n</code></pre> <p>Note that if you want to contribute, we'd appreciate it if you test your packages on both architectures (32 and 64 bits), which is only possible on a 64-bit Windows system. If you can't do that for some reason, we can test your pull requests on a 64-bit system.</p>"},{"location":"wiki/Creating-Packages/#install-package","title":"Install package","text":"<p>If the package build successfully, it's good to check its contents first before installing to see if it contains what you intended. When installing (using <code>pacman -U pkgname-pkgver-arch.tar.zst</code>), pacman checks for any filesystem conflicts and then places the package contents into your MSYS2 root as it would do with any other package. You can also remove the package using <code>pacman -R pkgname</code>.</p>"},{"location":"wiki/Creating-Packages/#test-package","title":"Test package","text":"<p>Make sure the package installed all the files which it's supposed to distribute: executables, shared and static libraries, configuration files, header files, licenses, documentation etc.</p> <p>Pay special attention to the configuration files and make sure they are not containing hard-coded path elements and are pointing to the right location. Typical config files:</p> <ul> <li><code>*-config</code> files in the <code>${prefix}/bin</code> directory</li> <li><code>*.pc</code> files for <code>pkg-config</code> in the <code>${prefix}/lib/pkgconfig</code> directory</li> <li><code>*.cmake</code> files in the <code>${prefix}/lib/cmake</code> directory</li> </ul> <p>Verify that the package works even if installed into a clean updated MSYS2 installation, preferably not in the default <code>C:\\msys{32,64}</code> location (and maybe even temporarily rename your primary MSYS2 installation root). This checks that you specified the runtime dependencies correctly and that the software doesn't try to use hard-coded paths from your build.</p>"},{"location":"wiki/Creating-Packages/#modify-package","title":"Modify package","text":"<p>If there are issues, fix them in your PKGBUILD and re-build or re-package as necessary. Make sure you're not using stale build products or source files from a previous build (use the <code>-C</code> flag for makepkg).</p>"},{"location":"wiki/Creating-Packages/#commit","title":"Commit","text":"<p>Integrate your recipe into your local clone of the msys2-packages or mingw-packages repository. In order to help us avoid accumulating useless commits in the repository, please follow these guidelines:</p> <ul> <li>create a new branch for your work</li> <li>put all your work into it, preferably in just 1 commit</li> <li>if you want to pull changes from our repository, use the rebasing strategy (<code>git pull --rebase</code>) to place your commits above ours, do not just merge</li> <li>if you need to change something in your recipe, amend your existing commit (<code>git commit --amend</code>)</li> <li>push your new branch onto your repository \"fork\" on your GitHub account, using <code>git push --force-with-lease</code> if necessary</li> </ul> <p>Although these guidelines (which rely heavily on rewriting history) are not suitable for public development on main branches (<code>master</code> etc.), they're an excellent match for this kind the iterative work-in-progress development that happens when contributing new packages.</p>"},{"location":"wiki/Creating-Packages/#send-pr","title":"Send PR","text":"<p>Open and send a pull request against the master branch of the official repositories on GitHub (links here). Please include a short description of what you're submitting and why. In case your recipe is not final yet, add \"[do not merge]\" to the title and explain in the description.</p>"},{"location":"wiki/Creating-Packages/#check","title":"Check","text":"<p>Our CI systems will automatically try to build your package. If it fails, try to figure out why. However, the CI systems are not perfect and unfortunately may fail even if your package is fine.</p> <p>The project maintainers will try to look at your PR and review it. This may take some time and sometimes happens in bursts, so don't be discouraged if you get no response for a few days, but don't be afraid to explicitly ask for help or a review on our IRC channel.</p>"},{"location":"wiki/Creating-Packages/#fix","title":"Fix","text":"<p>If there are any issues pointed out, try to fix them and update your pull request. GitHub will automatically refresh the pull request when you push to your branch, there is no need to create a new PR. After pushing, add a comment to the PR to notify the reviewers.</p> <p>If there are no issues with the package, it will be merged. Please note that this doesn't make the package immediately available through pacman. The binary repositories are updated in bursts.</p>"},{"location":"wiki/Creating-Packages/#upstream","title":"Upstream","text":"<p>In case you had to made changes in order to be able to compile and run properly (and hence created patches), please make an effort to submit proper patches and PRs to the upstream project so that the patches can be removed from our repositories and can be of use to other Windows developers.</p>"},{"location":"wiki/Creating-Packages/#resources","title":"Resources","text":"<p>Read through our wiki, especially the Porting section.</p>"},{"location":"wiki/Creating-Packages/#useful-packages-and-tools","title":"Useful packages and tools","text":"Package Purpose <code>mingw-w64-{i686,x86_64}-qt-creator</code> to build/debug qmake, qbs, autotools and cmake based packages <code>mingw-w64-{i686,x86_64}-codelite</code> if you dislike qt-creator <code>mingw-w64-{i686,x86_64}-gedit</code> to avoid notepad and notepad++ <code>mingw-w64-{i686,x86_64}-meld3</code> to compare files and directories <code>perl-ack</code> Faster, better replacement for <code>grep</code> <code>mingw-w64-{i686,x86_64}-ag</code> Very fast replacement for <code>grep</code> or <code>perl-ack</code>"},{"location":"wiki/Creating-Packages/#various-links","title":"Various links","text":"<ul> <li>bash on ArchWiki</li> </ul>"},{"location":"wiki/Devtopics/","title":"TODO LIST","text":"<p>Here are some topics and milestones that deserve more discussion or work. This page should serve as an overview of our long-term issues and goals and be a place to write down the decisions and open questions so that they don't get buried in IRC logs or mailing list archives. Each goal should be described in appropriate detail and should be broken up into smaller tasks for interested members to tackle the goal step by step.</p>"},{"location":"wiki/Devtopics/#finish-the-sourceforge-migration","title":"Finish the SourceForge migration","text":"<ul> <li>triage/migrate tickets from SF to GH; close them on SF afterwards</li> <li>archive the (closed) mailing list maybe? see mbox export</li> </ul>"},{"location":"wiki/Devtopics/#streamline-automation-for-the-package-reviewbuildupload-process","title":"Streamline automation for the package review/build/upload process","text":"<ul> <li>write down packaging rules (rules inherited from Arch Linux, rules about <code>pkgbase</code>, <code>pkgname</code>, <code>description</code>, FHS, 32+64 bits, ...)</li> <li>prepare automated checks to prevent mistakes (an idea: compare package file list between latest and new version of the package)</li> <li>also work towards reproducible builds (https://reproducible-builds.org/)</li> <li>don't build for mingw32 in CI if the package doesn't support it etc.</li> </ul>"},{"location":"wiki/Devtopics/#official-release","title":"Official release","text":"<p>MSYS2 is quite known but it's not obvious e.g. how stable and reliable it's supposed to be.  People are sometimes confusing it (in their minds, or in their words, or both) with MSys, much like MinGW-w64 is confused with MinGW.org.  The naming clash of MSYS2 the distribution vs. msys2 the emulation layer is also unfortunate (again reminiscent of the MinGW-w64 projects vs. its distributions).</p> <p>What to do:</p> <ul> <li>decide if there's a need for a different name for the whole thing; if yes, decide upon one</li> <li>split release Qt runtime from debug Qt runtime and Qt developer files (those debug and dev files are really huge)</li> <li>make core updates fool-proof</li> <li>maybe approve and polish one graphical front-end to pacman</li> <li>create and/or polish packages for most popular open-source software (browsers, video players, email clients, office suites, IDEs, web servers) and maybe some additional useful software (like password managers, games, image editors)</li> </ul>"},{"location":"wiki/Devtopics/#merge-with-cygwin","title":"Merge with Cygwin","text":"<p>The MSYS2 runtime is forked from Cygwin and the code bases are irregularly (but often) synchronized. There has been some talk about modifying Cygwin to make it pluggable so that the MSYS2 runtime can be reduced to a plugin DLL that will make all the desired behavior changes.</p> <p>There have been a lot of requests for additional POSIX-only software in MSYS2 (X, various daemons...) and the response was always \"MSYS2 is not for you; use Cygwin\". It would be nice if people could just install one POSIX emulation layer and have everything available from there.</p> <p>What to do:</p> <ul> <li>write down every difference between Cygwin and MSYS2 runtimes (see the patches)</li> <li>offer appropriate patches to Cygwin as configurable behavior (e.g. CYGWIN=winsymlinks:copy)</li> <li>design an interface prototype for unacceptable features; figure out if the idea is sound</li> <li>design and implement the plug-in interface in cooperation with Cygwin</li> <li>re-implement MSYS2 runtime as a Cygwin plugin</li> <li>figure out if we can use Cygwin package repositories or if MSYS2 repositories can be used from Cygwin</li> </ul> <p>Links:</p> <ul> <li>https://github.com/Alexpux/Cygwin/commit/4f756d6cc28179319ceccce01dd698de3f22c212</li> <li>https://sourceforge.net/p/mingw-w64/mailman/mingw-w64-public/thread/2F9017D3-8357-48C2-B887-A32FDF4E2141@gmail.com/</li> <li>http://sourceware.org/ml/cygwin/2014-12/msg00084.html</li> <li>https://github.com/Alexpux/MSYS2-packages/issues/83</li> </ul>"},{"location":"wiki/Devtopics/#connect-with-upstreams","title":"Connect with upstreams","text":"<p>Where possible, we shouldn't maintain a bunch of patches, but rather polish them and have them accepted by upstreams.</p> <p>Another change to consider is to start building only release versions of the core packages. Although MSYS2 is a rolling release distro, there seems to be little need to use less tested, potentially more buggy code directly from git. If there's a really important, not yet realeased patch, we apply it in the PKGBUILD until the next release. Currently the mingw-w64 toolchains are the most prominent examples.</p> <ul> <li>switch to release versions of upstream code</li> <li>improve technical quality of packages (make sure they follow all the packaging rules, tests are succeeding)</li> <li>send ideas and patches upstream, be prepared to compromise</li> </ul>"},{"location":"wiki/Devtopics/#connect-with-downstreams","title":"Connect with downstreams","text":"<p>Altough we are probably not so big among end-users yet, a lot of cross-platform developers know about MSYS2 and support it and even some big projects use it for their official builds.  Some applications and environments use MSYS2 internally.  We should get in touch with them and help them (it is, after all, one of the core goals of the project).</p> <p>Links:</p> <ul> <li>https://vcpkg.readthedocs.io/en/latest/maintainers/vcpkg_acquire_msys/</li> <li>https://chocolatey.org/packages/msys2/</li> <li>https://github.com/msys2/setup-msys2</li> <li>https://github.com/actions/virtual-environments/blob/master/images/win/Windows2019-Readme.md (https://github.com/actions/virtual-environments/pull/632 + https://github.com/actions/virtual-environments/pull/630)</li> <li>https://www.appveyor.com/docs/windows-images-software/#mingw-msys-cygwin</li> <li>https://docs.travis-ci.com/user/reference/windows/#how-do-i-use-msys2</li> <li>https://circleci.com/docs/2.0/hello-world-windows/</li> <li>https://github.com/git-for-windows/git/issues/284</li> <li>https://github.com/Alexpux/Cygwin/pull/8</li> <li>https://gitlab.haskell.org/ghc/ghc/wikis/building/preparation/windows</li> <li>https://wiki.qt.io/MSYS2</li> <li>https://www.gtk.org/download/windows.php#MSYS2</li> <li>https://cran.r-project.org/bin/windows/Rtools/</li> <li>https://wiki.inkscape.org/wiki/index.php?title=Compiling_Inkscape_on_Windows_with_MSYS2</li> <li>https://wiki.gnome.org/Initiatives/Windows</li> <li>https://github.com/xmrig/xmrig/wiki/Windows-Build</li> <li>https://github.com/LuminanceHDR/LuminanceHDR/tree/master/build_files/platforms/msys2</li> <li>https://sigrok.org/gitweb/?p=sigrok-util.git;a=blob;f=cross-compile/msys2/README</li> <li>https://blogs.gnome.org/nacho/2014/08/01/how-to-build-your-gtk-application-on-windows/</li> </ul>"},{"location":"wiki/Devtopics/#get-more-people","title":"Get more people","text":"<p>The MSYS2 team is pretty small and we could use more people.  Some contributors become pretty active and motivated from time to time, but often they burn out after a while.  Since there are so few of core people, the occasional interested users, contributors and issue reporters are often greeted by silence and turned off.</p> <p>What to do to get them:</p> <ul> <li>respond to them on IRC, Matrix, ML, handle their bug reports and contributions on GitHub in a timely fashion</li> <li>good documentation helps with frequent inquiries, automated checks help with code reviews</li> <li>get money and pay people?</li> <li>other ideas?</li> </ul> <p>Links:</p> <ul> <li>https://www.msys2.org/wiki/Contributing-to-MSYS2/</li> </ul>"},{"location":"wiki/Devtopics/#fix-pacman-errors-wrt-conflicts-in-binfoo-vs-binfooexe","title":"Fix pacman errors wrt. conflicts in <code>bin/foo</code> vs <code>bin/foo.exe</code>","text":"<p>The runtime emulates extension-less executables by also looking for <code>.exe</code> on various FS calls. (There are more of these hacks, for example for symlink emulation.) This is causing pacman to complain when two packages independently provide both <code>foo</code> and <code>foo.exe</code>, or even worse <code>dir/</code> and <code>dir.exe</code>. People have to either disregard these conflicts with <code>--force</code>or (re-)install packages in a specific order.</p> <p>A possible solution to these conflicts would be to disable the .exe interpolation, but then something would break, either users wouldn't be able to either run MSYS2 executables directly from Windows, or couldn't use the short extension-less names of commands in MSYS2. Therefore there also has to be a change that will mitigate that. We can for example design some passes for <code>makepkg</code>:</p> <ul> <li>make sure every <code>.exe</code> going into <code>{,/usr}/{bin,lib,libexec}/</code> has its extension stripped</li> <li>make sure only <code>.{exe,dll}</code> go into <code>/mingw{32,64}/bin/</code></li> <li>build a good <code>.exe</code> wrapper for every executable in MSYS-land</li> <li>build a good shell wrapper for every executable in MINGW-land</li> </ul> <p>This way, we can even make all non-binaries like shell scripts directly executable from Windows.</p> <p>What to help with:</p> <ul> <li>think/discuss if this is a good idea</li> </ul>"},{"location":"wiki/Devtopics/#provide-more-mingw-w64-versions-of-common-cli-tools","title":"Provide more mingw-w64 versions of common CLI tools","text":"<p>It would be nice to allow people to have as complete as possible GNU-like environment without having to fall back to msys2 bash and the likes. The roadblock in this is that by putting every possible tool into <code>/mingw{32,64}/bin</code> will inevitably screw up native (i.e. non-cross) builds. Ideas for solutions:</p> <ul> <li>for every tool that's known to cause problems inside of MSYS2, include shell scripts in <code>/mingw{32,64}/bin/</code> that take priority over the <code>.exe</code>s.</li> <li>separate the essential build tools from everything else; (by using symlinks, aliases, or just using the package manager) we could have gcc, binutils and friends in <code>/mingw{32,64}/bin/</code> and everything else for instance in <code>/mingw{32,64}/morebin/</code> so that a MSYS2/MINGW shell only uses the <code>bin</code>, but people can opt in for using <code>morebin</code> outside of MSYS2</li> </ul> <p>What to help with:</p> <ul> <li>design, test, agree on, and implement a way to prevent problems when building</li> <li>port all the tools!</li> </ul> <p>Links:</p> <ul> <li>Pull requests from @pfmoore</li> <li>GnuWin</li> <li>UnxUtils</li> <li>GNU on Windows</li> <li>mksh/Win32</li> <li>busybox-w32 and MinGit and mingw-w64-busybox</li> </ul>"},{"location":"wiki/Devtopics/#midipix","title":"Midipix","text":"<p>Maybe?</p>"},{"location":"wiki/Distributing/","title":"Distributing","text":"<p>[ This page is a stub. Help us by sending your experience and ideas for improvements. ]</p>"},{"location":"wiki/Distributing/#possibly-useful-sources-of-information","title":"Possibly useful sources of information","text":"<ul> <li>Styrene from Andrew Chadwick</li> <li>the build scripts for Git for Windows, especially make-file-list.sh</li> <li>a <code>deploy.sh</code> script from @rubenvb</li> <li>a Makefile rule from @matlo</li> <li>a newer Makefile rule from @matlo</li> <li>the <code>pactree</code> command</li> <li>a <code>copy_dependencies.py</code> script for librepilot from @filnet, discussion</li> <li>the rtools-installer project</li> <li>the build script for quodlibet</li> </ul>"},{"location":"wiki/GDB-qtcreator/","title":"Qt Creator","text":"<p>This page is extremely work-in-progress. Eventually it will cover setting up Qt Creator so you can \"Start and Debug External Application ...\" (you need to build it from source to get access to the latest patch that makes this workable), rebuilding and reinstalling the involved packages in debug, !strip mode and debugging them. The also being able to see Python callstacks and pretty printing of GDB internals in-case you are debugging those sorts of things. For now, this is all I have:</p> <p>.. To see Python Callstacks and vars when debugging something that intermixes Python and C/C++ (e.g. pygtk) .. add to .gdbinit or QtCreator Tools-&gt;Options-&gt;Debugger-&gt;GDB-&gt;Additional Startup Commands, enter   python   sys.path.append('C:/msys64/mingw64/share/gdb/python3')   import python-gdb   reload(python-gdb)   end</p>"},{"location":"wiki/History/","title":"MSYS2 History","text":""},{"location":"wiki/History/#msys2","title":"MSYS2","text":"<p>MSYS2 is an independent rewrite of MSYS, based on modern Cygwin and MinGW-w64 with the aim of better interoperability with native Windows software.</p> <p>The name is a contraction of Minimal SYStem 2, and aims to provide support to facilitate using the bash shell, Autotools, revision control systems and the like for building native Windows applications using MinGW-w64 toolchains.</p> <p>We wanted a package management system to provide easy installation of packages, and ported Pacman (known from Arch Linux). This brings many powerful features such as dependency resolution and simple complete system upgrades, as well as providing the build system which is used to make these packages.</p>"},{"location":"wiki/History/#cygwin","title":"Cygwin","text":"<p>Cygwin is a POSIX platform atop of Windows (the Win32 subsystem), running in user-mode. It requires a POSIX compatibility layer at runtime. It doesn't emulate Linux, it's not the same thing as WSL.</p> <p>It is our hope that MSYS2 be viewed as a complementary off-shot of Cygwin (even hopefully by the Cygwin developers!), and we still hold out hopes that MSYS2 can someday operate as a special mode for Cygwin (via a DLL plugin mechanism).</p>"},{"location":"wiki/History/#mingw-w64","title":"MinGW-w64","text":"<p>MinGW is an abbreviation of Minimalist GNU for Windows. The idea of MinGW is to provide a development platform for building cross-platform applications on Windows. The important pieces are:</p> <ul> <li>a set of FOSS Windows specific header files and import libraries which enable the use of the Windows API,</li> <li>a supplementary library and a runtime that fill in some gaps.</li> </ul> <p>... but the term generally encompasses the cross-platform GNU development tools:</p> <ul> <li>GNU Compiler Collection (GCC),</li> <li>GNU Binutils (assembler, linker, archive manager),</li> <li>GNU Debugger (GDB),</li> <li>and miscellaneous utilities.</li> </ul> <p>There are at least two projects implementing this idea:</p> <ul> <li>the original MinGW project, sometimes referred to as mingw.org</li> <li>and the MinGW-w64 project.</li> </ul> <p>The MinGW-w64 project itself doesn't aim to be a software distribution. There are multiple builds of mingw-w64 toolchains and multiple software distributions built using MinGW-w64.</p>"},{"location":"wiki/History/#msys-and-mingw","title":"MSYS and MinGW","text":"<p>MinGW is a software distribution and development platform. It is accompanied by MSYS, an old Cygwin fork. The MSYS2 and MinGW-w64 projects are not associated with MSYS and MinGW, other than by the name and common goals.</p> <p>MSYS2 is ideologically a successor to MSYS and MinGW. MSYS -- although definitely useful -- is really old and getting in the way of developers. MSYS2 was created to replace the original MSYS while avoiding its problems.</p>"},{"location":"wiki/Home/","title":"Welcome to the MSYS2 wiki","text":"<p>Welcome to the MSYS2 wiki</p> <ul> <li>Introduction - overview and important information</li> <li>Installing and upgrading - required reading for all users</li> <li>History - about the project's inception and origins</li> <li>Re-installing from scratch - in case of unrecoverable problems</li> <li>Creating packages - how packages are built and how to make new ones</li> <li>MSYS2 vs. Cygwin - differences and similarities</li> <li>MSYS2 on Wine - how to install and use MSYS2 under Wine [sadly broken with current version of MSYS2 and no-one is actively working on a fix as far as we know]</li> <li>Porting for MSYS2 or MinGW-w64 - useful resources and common issues</li> <li>Launchers - various ways to launch MSYS2 shells</li> <li>Distributing software without pacman - how to bundle your software built using MSYS2, including all required dependencies, to non-MSYS2-users</li> <li>About terminals, consoles and shells</li> <li>Setting up SSHd on MSYS2</li> <li>Sudo on MSYS2</li> <li>Developer discussion</li> <li>Signing packages (draft)</li> <li>Tips for investigating package issues using GDB on Qt Creator (draft)</li> </ul> <p>More documentation:</p> <p>If you have any problems with the POSIX side of MSYS2 (e.g. ssh, home directories, user accounts, native symlinks, signal handling, ...), try to consult the Cygwin documentation first, as a lot of what's written there applies to MSYS2 as well.</p> <p>There is also an excellent introduction from Matthieu Vachon describing MSYS2, the shells, pacman and other stuff in a less technical, more practical way.</p> <p>Some pages on the Git for Windows wiki are relevant to MSYS2 as well.</p> <p>There are various communication channels set up, including the #msys2 IRC channel on OFTC and the mailing list at msys2-users@lists.sourceforge.net.</p> <p>With thanks to:</p> <ul> <li>The MinGW-w64 Project</li> <li>The Cygwin Project</li> <li>The Qt-Project</li> </ul> <p>... and all of the other Open Source software projects we build, package and distribute</p>"},{"location":"wiki/How-does-MSYS2-differ-from-Cygwin/","title":"How does MSYS2 differ from Cygwin?","text":""},{"location":"wiki/How-does-MSYS2-differ-from-Cygwin/#goals","title":"Goals","text":"<p>Cygwin and MSYS2 -- as projects -- have significantly different goals.</p> <p>Cygwin tries to bring a POSIX-compatible environment to Windows so that most software that runs on unices will build and run on Cygwin without any significant modifications. Cygwin provides a large collection of packages containing such software, and libraries for their development.</p> <p>MSYS2 tries to provide an environment for building native Windows software. MSYS2 provides a large collection of packages containing such software, and libraries for their development. As a large portion of the software uses GNU build tools which are tightly coupled to the unix world, this environment is also POSIX-compatible, and is in fact based on Cygwin. </p> <p>MSYS2 provides a minimal shell required to run autotools and other build systems which get the source for software from the Internet from different repositories, configure them and build them. The shell and core tools exist mainly to allow porting Unix programs to run natively on Windows (i.e. without requiring a POSIX emulation layer). MSYS2 doesn't try to duplicate Cygwin's efforts more than necessary, so the number of provided POSIX-emulated software is very small.</p>"},{"location":"wiki/How-does-MSYS2-differ-from-Cygwin/#packages","title":"Packages","text":"<p>MSYS2 uses Pacman (known from Arch Linux) to manage its packages and comes with three different package repositories:</p> <ul> <li><code>msys2</code>: Containing MSYS2-dependent software</li> <li><code>mingw64</code>: Containing 64-bit native Windows software (compiled with mingw-w64 x86_64 toolchain)</li> <li><code>mingw32</code>: Containing 32-bit native Windows software (compiled with mingw-w64 i686 toolchain)</li> </ul> <p>Cygwin comes only with Cygwin-dependent software. It uses its own package management system, commonly called setup.exe.</p>"},{"location":"wiki/How-does-MSYS2-differ-from-Cygwin/#runtime","title":"Runtime","text":"<p>Cygwin provides a runtime library called <code>cygwin1.dll</code> that provides the POSIX compatibility layer where necessary. The MSYS2 variant of this library is called <code>msys-2.0.dll</code> and includes the following changes to support using native Windows programs:</p> <ol> <li>Automatic path mangling of command line arguments and environment variables to Windows form on the fly. (This can be selectively turned off.)</li> <li>Ability to change the reported OS using an environment variable (<code>MSYSTEM</code>, with values of <code>MSYS2</code>, <code>MINGW32</code>, and <code>MINGW64</code>).  This allows mingw-w64 software to be built in native build mode (as opposed to cross-compilation mode).</li> <li>Conversion of output of native Windown applications from Windows line endings to POSIX line endings by removing trailing <code>'\\r'</code> characters, so that e.g. <code>bb=$(gcc --print-search-dirs)</code> works as expected.</li> <li>Replacement of symlinks with copying, so that Windows programs don't trip up on these files. MSYS2 also supports creating native NTFS symlinks, but these are limited in other ways.</li> <li>Removal of the <code>/cygdrive</code> prefix for automounts. This is to retain compatibility with MSYS-enabled software that makes assumptions about <code>/c/</code> being equivalent to <code>C:/</code>, and it saves a bit of typing.</li> <li>Switch to <code>noacl</code> on default mounts. This prevents any permission mangling from MSYS2.</li> <li>MSYS2 releases might be ahead of or behind Cygwin releases.</li> </ol> <p>Other notable differences:</p> <ol> <li>System root is <code>/usr</code>, not <code>/</code>.</li> <li>Removal of system integration stuff, such as <code>cyglsa</code>, <code>cygserver</code>, <code>cygstart</code>...</li> <li>Dynamic libraries are prefixed <code>msys</code> instead of <code>cyg</code> (most other platforms, including mingw-w64, use <code>lib</code>).</li> <li>Addition of the \"-W\" option to the <code>pwd</code> command in shells for compatibility with the old MSYS.</li> <li>Various changes in utilities to help retain compatibility and interoperability.  An example is Perl reporting <code>msys</code> as <code>$^O</code>, or Sed recognizing CRLF as a line ending.</li> </ol>"},{"location":"wiki/JIT-Debugging/","title":"Just-in-time Debugging","text":""},{"location":"wiki/JIT-Debugging/#msys2-processes","title":"MSYS2 processes","text":"<p>To get just-in-time debugging of MSYS2 processes, use the <code>error_start</code> <code>MSYS</code> environment variable setting: <pre><code>export MSYS=\"error_start:$(cygpath -w /usr/bin/gdb)\"\n./crashy.exe\n</code></pre></p>"},{"location":"wiki/JIT-Debugging/#native-windows-processes","title":"Native Windows processes","text":"<p>MINGW gdb can be used as a Windows JIT debugger. This is documented here under <code>signal-event</code>.</p> <p>As Administrator: <pre><code>regtool add -w '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug'\nregtool set -w '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug/Debugger' \\\"$(cygpath -w /mingw64/bin/gdb.exe)'\" -ex \"attach %ld\" -ex \"signal-event %ld\" -ex \"continue\"'\nregtool set -w '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug/Auto' 1\n\nregtool add -W '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug'\nregtool set -W '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug/Debugger' \\\"$(cygpath -w /mingw32/bin/gdb.exe)'\" -ex \"attach %ld\" -ex \"signal-event %ld\" -ex \"continue\"'\nregtool set -W '/HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug/Auto' 1\n</code></pre></p>"},{"location":"wiki/JIT-Debugging/#native-windows-processes-started-from-msys2","title":"Native Windows processes started from MSYS2","text":"<p>When a native process which was started (possibly indirectly) from an MSYS2 process (such as <code>bash</code>) crashes, it does not invoke the registered debugger (or Windows Error Reporting), unless the <code>SetErrorMode</code> <code>SEM_NOGPFAULTERRORBOX</code> flag was cleared in the meantime (<code>SetErrorMode</code> flags are inherited from a parent process by default).  As of msys2-runtime <code>3.2.0-2</code>, it is possible to tell MSYS2 to create processes without inheriting its error mode flags by setting an <code>MSYS</code> environment variable setting: <pre><code>export MSYS=winjitdebug\nexec bash\n./crashy.exe\n</code></pre> (note that the option needs to be set in the parent process, so <code>bash</code> needs to be restarted, assuming you are starting processes from <code>bash</code>).</p>"},{"location":"wiki/Launchers/","title":"Launchers","text":"<p>You should not launch sh.exe directly as that doesn't start a login shell or set the correct environment variables for the type of shell that you want to use. Instead, your best choices are:</p> <p>msys2_shell.cmd, the improved multi-purpose batch file from the <code>filesystem</code> package.  Run <code>msys2_shell.cmd --help</code> for usage.</p> <p>msys2.exe, mingw64.exe, mingw32.exe, the new pinnable launchers from the <code>msys2-launcher</code> package from @Elieux. GitHub, discussion, discussion</p> <p>A nice explanation how to set up ConEmu to run MSYS2 inside it by jstine.</p> <p>Configuration for an MSYS2 shell in Visual Studio Code.</p> <p>msys2_env.bat from @DavidEGrayson. Gist, discussion</p> <p>msys2.cmd, mingw64.cmd, mingw32.cmd from @Elieux. Gist</p> <p>smart_msys from @jhasse. GitHub, discussion</p> <p>MSYS2 here, MINGW64 here and MINGW32 here Explorer context menu items from @Elieux. Gist</p> <p>msystem.bat and cmd/clink integration in the <code>filesystem-cmd</code> package from @userzimmermann. PR, commits</p> <p>git-bash.exe and start-ssh-agent.cmd as part of the Git for Windows project from @dscho. GitHub, GitHub</p> <p>Open MSYS2 here from @magthe, with contributions from @sushovan-dw and @ryanpfeeley. Gist+discussion</p> <p>msys2_shell.bat, mingw64_shell.bat and mingw32_shell.bat, the old-school batch files from old versions of the <code>filesystem</code> package.</p>"},{"location":"wiki/Launchers/#the-idea","title":"The idea","text":"<p>If you need to start a shell correctly, but none of the ways above suit you, devise your own way based on this knowledge:</p> <ul> <li>set <code>MSYSTEM=...</code> into the environment, with the value of either <code>MSYS</code>, <code>MINGW32</code>, or <code>MINGW64</code></li> <li>then run a login shell</li> </ul> <p>The typical one-liner if your options are limited is <code>C:\\\\msys64\\\\usr\\\\bin\\\\env MSYSTEM=MSYS /usr/bin/bash -li</code>.</p> <p>Caveats:</p> <ul> <li>MSYS2 inherits multi-user capabilities from Cygwin and there is a notion of user's default shell.  Not everyone's default shell is bash.  To correctly figure out the default shell from outside (i.e. without directly calling the POSIX APIs), you can use this shell one-liner or an equivalent: <code>getent passwd $(whoami) | cut -d: -f7</code></li> <li>There are other environment variables that control MSYS2 at runtime or initialization.  See the source of launchers above to figure them out if needed.</li> <li>You might need to set <code>CHERE_INVOKING=1</code> for the shell to stay in the current working directory.</li> <li>If you need to run a specific command instead of an interactive shell, you still need to go through a login shell, e.g. <code>... /usr/bin/bash -lc python</code>.</li> </ul>"},{"location":"wiki/MSYS2-installation/","title":"MSYS2-Installation","text":""},{"location":"wiki/MSYS2-installation/#i-downloading","title":"I. Downloading","text":"<p>MSYS2 ships in the form of installers and base archives. They can be installed or extracted to any place on your computer, but you MUST use folder names that consist of only ascii characters and no spaces (also it makes good sense to put it in a path that doesn't use many characters due to PATH_MAX being 260; C:\\msys64 is ideal).   You can download the installers or base MSYS2 archives from the links below:</p> <ul> <li>64-bit</li> </ul>"},{"location":"wiki/MSYS2-installation/#ii-installation","title":"II. Installation","text":"<p>The installers and base archives only contain the tools necessary to 1) start MSYS2 2) update the pre-installed packages and 3) install new packages.</p> <ul> <li> <p>After installing or extracting MSYS2 you should start MSYS2 by executing msys2_shell.cmd.   (if you did not use an installer and this is first time running of MSYS2 after unpacking, then at this point it will create the files and settings necessary for it to function properly. After this initial run you MUST restart MSYS2 so that the settings are correct)</p> </li> <li> <p>Now you can update the base MSYS2 packages to their latest versions. MSYS2 comes with a ported version of the [Pacman][1] package manager (known from Arch Linux).</p> </li> </ul>"},{"location":"wiki/MSYS2-installation/#iii-updating-packages","title":"III. Updating packages","text":"<p>Partial upgrades (e.g. updating just <code>pacman</code> while not updating <code>msys2-runtime</code>) are not supported and are expected to break stuff.</p> <ol> <li> <p>Since pacman 5.0.1.6403, you can just:</p> <ul> <li>Run <code>pacman -Syuu</code>. Follow the instructions. Repeat this step until it says there are no packages to update.</li> </ul> </li> <li> <p>Since pacman 4.2.1.6187, there's an <code>update-core</code> script that helps you to update MSYS2 in the right way. To update your MSYS2 installation you need:</p> <ul> <li>Run <code>update-core</code>. If one of the packages is updated during script run you MUST restart MSYS2</li> <li>Run <code>pacman -Suu</code> to update the rest of the packages (allowing downgrades).</li> </ul> </li> <li> <p>In older MSYS2 installations, follow these steps:</p> <ul> <li>Before updating you should synchronize your local package databases with the latest repositories: <code>pacman -Sy</code>  This command connects to the remote repositories and downloads the package databases.</li> <li>The next step is to update the installed packages (do this initially and as often as you want thereafter):  The 'normal' way (don't do this) would be to simply issue: <code>pacman -Suu</code>  ... however, because all MSYS2 programs share the same address space for DLLs due to how MSYS2 (well, Cygwin) implements 'fork', updating bash, MSYS2 or Pacman itself can cause subsequent package updates to fail. For this reason, the safest procedure for updating MSYS2 is to do it in two stages; first those 'core' MSYS2 packages: <code>pacman --needed -S bash pacman pacman-mirrors msys2-runtime</code> ... if any packages got updated during this then you MUST restart MSYS2 because files that are provided by these packages will be in use and after update you can get fork errors - you need to exit all MSYS2 shells then re-launch <code>msys2_shell.bat</code></li> <li>Finally you can do an update of the remaining packages by issuing: <code>pacman -Suu</code></li> </ul> </li> </ol>"},{"location":"wiki/MSYS2-installation/#iv-general-package-management","title":"IV. General Package Management","text":"<ol> <li>Installing new packages:     <code>pacman -S &lt;package_names|package_groups&gt;</code>      For example, <code>pacman -S make gettext base-devel</code>      In this example, <code>base-devel</code> is a package group which contains many packages. If you try to install a package group, Pacman will ask you whether you want to install one package from the group or all of the packages from the group.</li> <li>Removing packages:     <code>pacman -R &lt;package_names|package_groups&gt;</code></li> <li>Searching for packages:     <code>pacman -Ss &lt;name_pattern&gt;</code></li> </ol>"},{"location":"wiki/MSYS2-installation/#v-issues-and-workarounds","title":"V. Issues and workarounds","text":"<ol> <li>Please read \"III.\" above, carefully :-) We will continue working towards trouble-free updates.</li> <li>If you do run into failures to run post-install scripts, it's really nothing to panic about. Simply make a list of the packages that failed to install correctly, exit all your MSYS2 shells (make sure that they fully exit and no mintty/bash processes are running). Then launch a new MSYS2 shell, and issue: <code>pacman -S &lt;list-of-packages-that-failed-to-install&gt;</code></li> <li>If you get <code>error: failed to prepare transaction (could not satisfy dependencies)</code> complaining about <code>msys2-runtime-devel</code> when you try to update the core, you need to update this package alongside <code>msys2-runtime</code> and the other core packages.</li> <li>Sometimes a package upgrade fails with <code>failed to commit transaction (conflicting files)</code> and <code>some-pkg: /path/to/some/file exists in filesystem</code>. If you're sure you didn't put the offending files there manually, move or delete the files and start the upgrade again.</li> <li>If your MSYS2 is unable to start after an upgrade, it's possible you just have some lingering MSYS2 processes (loaded with an older version of the runtime) that are conflicting with the processes you're trying to start. Hunt down these processes in your favorite task manager and kill them, or just reboot your system.</li> <li>After an update, you get <code>error: GPGME error: No data</code> then you were unlucky and caught SourceForge at a bad time. Check <code>/var/lib/pacman/sync</code> and if the files in there contain an HTML formatted error page, then delete those files and try again.</li> </ol>"},{"location":"wiki/MSYS2-introduction/","title":"MSYS2-Introduction","text":"<p>MSYS2 is software distribution and a building platform for Windows. It provides a Unix-like environment, a command-line interface and a software repository making it easier to install, use, build and port software on Windows. That means Bash, Autotools, Make, Git, GCC, GDB..., all easily installable through Pacman, a fully-featured package manager.</p> <p>It is an independent rewrite of MSys, based on modern Cygwin (POSIX compatibility layer) and MinGW-w64 with the aim of better interoperability with native Windows software.</p> <p>Both 32-bit and 64-bit variants exist and receive mostly the same level of support.</p>"},{"location":"wiki/MSYS2-introduction/#subsystems","title":"Subsystems","text":"<p>MSYS2 consists of three subsystems and their corresponding package repositories, <code>msys2</code>, <code>mingw32</code>, and <code>mingw64</code>.</p> <p>The <code>mingw</code> subsystems provide native Windows programs and are the main focus of the project. These programs are built to co-operate well with other Windows programs, independently of the other subsystems. This part builds on the MinGW-w64 project.</p> <p>The <code>msys2</code> subsystem provides an emulated mostly-POSIX-compliant environment for building software, package management, and shell scripting. These programs live in a virtual single-root filesystem (the root is the MSYS2 installation directory). Some effort is made to have the programs work well with native Windows programs, but it's not seamless. This part builds on the Cygwin project.</p> <p>Each of the subsystems provides its own native (i.e. target=host) compiler toolchain, in <code>mingw-w64-i686-toolchain</code>, and <code>mingw-w64-x86_64-toolchain</code>. There are also cross compiler toolchains with host={i686,x86_64}-pc-msys and target={i686,x86_64}-w64-mingw32 in <code>mingw-w64-cross-toolchain</code>, but these are of limited use because there are no library packages for them.</p>"},{"location":"wiki/MSYS2-introduction/#shells","title":"Shells","text":"<p>Every subsystem has an associated \"shell\", which is essentially a set of environment variables that allow the subsystems to co-operate properly. These shells can be invoked using launchers in the MSYS2 installation directory or using the shortcuts in the Windows Start menu. The launchers set the <code>MSYSTEM</code> variable and open a terminal window (mintty) with a proper shell (bash). Bash in turn sources <code>/etc/profile</code> which sets the environment depending on the value of <code>MSYSTEM</code>.</p> <p>Without the correct environment, various things may and will (sometimes silently) break. The exception is using mingw subsystems from pure Windows, which shouldn't require any special environment apart from an entry in <code>PATH</code>. Do not set <code>MSYSTEM</code> outside of the shells, because that will also break things.</p>"},{"location":"wiki/MSYS2-introduction/#path","title":"PATH","text":"<p>For optimal usage, MSYS2 automatically strips your <code>PATH</code> environment variable, essentially only leaving <code>C:\\Windows\\System32</code> and few others. This behavior can be controlled by setting the variable <code>MSYS2_PATH_TYPE</code> before starting a shell or using a correct argument when executing the launcher script. Beware that mixing in programs from other MSYS2 installations, Cygwin installations, compiler toolchains or even various other programs is not supported and will probably break things in unexpected ways. Do not have these things in <code>PATH</code> when running MSYS2 unless you know what you're doing.</p> <p>Use <code>msys2</code> shell for running <code>pacman</code>, <code>makepkg</code>, <code>makepkg-mingw</code> and for building POSIX-dependent software that you don't intend to distribute. Use <code>mingw</code> shells for building native Windows software and other tasks.</p>"},{"location":"wiki/MSYS2-introduction/#packages","title":"Packages","text":"<p>MSYS2 uses a port of pacman (known from Arch Linux) for package management. This brings many powerful features such as dependency resolution and simple complete system upgrades, as well as providing the build system (<code>makepkg-mingw</code>) - which is used to make these packages.</p> <p>Packages for <code>msys2</code> are built from recipes in the <code>msys2-packages</code> Git repository, packages for <code>mingw</code> are in <code>mingw-packages</code>. Official repositories are on GitHub under user the msys2 organization. When looking for <code>msys2</code> packages or deciding to create a new one, keep in mind that MSYS2 doesn't intend to compete with Cygwin or duplicate their efforts. The set of things that belong to the <code>msys2</code> subsystem is pretty small and needs to stay that way.</p> <p>You might be wondering why there appears to be only one architecture variant of the <code>msys2</code> repository. In reality there are two, but the decision about which one to use is made at the time you install it, depending on whether you installed the i686 or the x86_64 version. It is possible to install both if you wish. Actually, you can have multiple installations of each on your computer, but you should never run programs from two different MSYS2 XXbit variants at the same time due to DLL address space and version conflicts. Also note that the uninstaller will only remove the most recently installed one of each variant).</p>"},{"location":"wiki/MSYS2-introduction/#file-system","title":"File system","text":"<p>The virtual filesystem contains:</p> Paths Contents <code>/bin</code>, <code>/dev</code>, <code>/home</code>, <code>/opt</code>, <code>/proc</code>, <code>/tmp</code>, <code>/var</code> essential POSIX stuff <code>/etc</code>, <code>/usr</code> <code>msys2</code> subsystem <code>/mingw32</code>, <code>/mingw64</code> <code>mingw</code> subsystems <code>/c</code>, <code>/d</code>, ... mount points for Windows drives <code>/*.xml</code>, <code>/maintenancetool.*</code>, <code>InstallationLog.txt</code> (un)installer <code>/autorebase.bat</code>, <code>/msys2_shell.cmd</code>, <code>/msys2.ico</code> shell entry points"},{"location":"wiki/MSYS2-reinstallation/","title":"Re-installing MSYS2","text":""},{"location":"wiki/MSYS2-reinstallation/#introduction","title":"Introduction","text":"<p>When we release new installers and new base tar.zst packages, we'd appreciate it if people can help out by testing complete re-installs of their entire MSYS2. The procedure is safe as it is fully reversible. Also, if your system gets messed up, this procedure could help to get you running again.</p>"},{"location":"wiki/MSYS2-reinstallation/#re-installing","title":"Re-installing","text":"<ol> <li> <p>Run your existing MSYS2 installation via <code>msys2_shell.cmd</code>.</p> </li> <li> <p>Make a list of installed packages:</p> <pre><code>pacman -Qqe | xargs echo &gt; /c/packages.txt ; exit\n</code></pre> </li> <li> <p>Rename your <code>msys??</code> folder to <code>msys??.old</code>.</p> </li> <li> <p>Run the installer (or untar the base package, run <code>msys2_shell.cmd</code>, then exit it).</p> </li> <li> <p>To save server bandwidth and your time, move your old cached packages directory to the new installation. In Explorer, remove the empty <code>msys??\\var\\cache\\pacman\\pkg</code> folder, then replace it with <code>msys??.old\\var\\cache\\pacman\\pkg</code>.</p> </li> <li> <p>Run the new MSYS2 installation via <code>msys2_shell.cmd</code>.</p> </li> <li> <p>Update the package databases:</p> <pre><code>pacman -Sy\n</code></pre> </li> <li> <p>Update the core packages:</p> <pre><code>pacman --needed -S bash pacman pacman-mirrors msys2-runtime\n</code></pre> </li> <li> <p>If any packages got updated during step 8, you MUST restart MSYS2, otherwise you can get fork errors in the next step. You need to exit all MSYS2 shells (and if using MSYS2 32bit, run <code>autorebase.bat</code>) then re-launch <code>msys2_shell.cmd</code>.</p> </li> <li> <p>Re-install your old packages, by entering:</p> <pre><code>pacman -S --needed $(cat /c/packages.txt)\n</code></pre> </li> </ol> <p>You may also want to compare your new $HOME folder with your old one and merge across your dotfiles and other files.</p>"},{"location":"wiki/MSYS2-reinstallation/#reversing-the-procedure","title":"Reversing the procedure","text":"<ol> <li>Move the pkg folder back from <code>msys??\\var\\cache\\pacman\\pkg</code> to <code>msys??.old\\var\\cache\\pacman\\pkg</code>.</li> <li>Delete the new <code>msys??</code> folder.</li> <li>Rename <code>msys??.old</code> to <code>msys??</code>.</li> </ol>"},{"location":"wiki/MSYS2-reinstallation/#finally","title":"Finally","text":"<p>It would be good if you can try working with the new installation to see if everything's OK, and if not, please report a bug (try to use e.g. strace or procmon to figure out what goes wrong and meld3 or Beyond Compare to help track down which files are different).</p>"},{"location":"wiki/Porting/","title":"Porting","text":"<p>While in our humble opinions, MSYS2 makes collaborative, organised development of open-source software on Windows a workable proposition, there are a few things to be aware of that we commonly run into, mostly due to the design decisions made by Microsoft, our preference for using native tools and compilers rather than cross msys2-to-native ones and our wish to be as flexible as we can be.</p>"},{"location":"wiki/Porting/#mingw32-make","title":"mingw32-make","text":"<p>MSYS2 provides two versions of make, one in the <code>make</code> package and one in the <code>mingw-w64-{i686,x86_64}-make</code> packages. The latter one is called <code>mingw32-make</code> on command line, is fully native and doesn't depend on <code>msys2</code> shells. The downside is that it doesn't work with many <code>Makefile</code>s. Unless you know what you're doing, use the regular <code>make</code>.</p>"},{"location":"wiki/Porting/#detecting-version-of-msys-from-gnu-make","title":"Detecting version of MSYS from GNU make","text":"<p>You can use the following <code>Makefile</code> snippet to detect whether you are running GNU make from an MSYS or an MSYS2 shell. If you run it through <code>mingw32-make.exe</code> from <code>cmd.exe</code> you will likely get an error since <code>uname</code> will not be found on your <code>PATH</code>. If you run it through <code>mingw32-make.exe</code> from one of the MSYS shells, it will set <code>msys_version</code> to 1 or 2 as appropriate. On any other system with <code>uname</code> present, it will set it to 0.</p> <pre><code>msys_version := $(if $(findstring Msys, $(shell uname -o)),$(word 1, $(subst ., ,$(shell uname -r))),0)\n$(info The version of MSYS you are running is $(msys_version) (0 meaning not MSYS at all))\n</code></pre>"},{"location":"wiki/Porting/#platform-checks","title":"Platform checks","text":"<p>You may need to use platform checks to switch between behaviour suited for MSYS2 and the default one. Some useful identifiers:</p> Identifier Platform(s) Usage <code>_WIN32</code> mingw, msvc C code (<code>#ifdef ...</code>) <code>_WIN64</code> 64-bit mingw, 64-bit msvc C code (<code>#ifdef ...</code>) <code>__CYGWIN__</code> msys2, cygwin C code (<code>#ifdef ...</code>) <code>__MSYS__</code> msys2 C code (<code>#ifdef ...</code>) <code>x86_64-pc-msys2</code> 64-bit msys2 Build scripts (<code>if [ $host = '...' ]</code>) <code>i686-pc-msys2</code> 32-bit msys2 Build scripts (<code>if [ $host = '...' ]</code>) <code>x86_64-w64-mingw32</code> 64-bit mingw Build scripts (<code>if [ $host = '...' ]</code>) <code>i686-w64-mingw32</code> 32-bit mingw Build scripts (<code>if [ $host = '...' ]</code>) <code>cygwin</code> msys2 Python (<code>sys.platform</code>) <code>win32</code> mingw Python (<code>sys.platform</code>)"},{"location":"wiki/Porting/#filesystem-namespaces","title":"Filesystem namespaces","text":"<p>In MSYS2 there are two different filesystem namespaces in play. If you are building purely <code>msys2</code> software, you can ignore the Windows filesystem namespace entirely, however, when building native software using MSYS2's tools, you must be mindful that when <code>msys2</code> executes a native program, it will translate environment variables and command arguments from msys2-form to native-form. To do this, it converts things that look like <code>msys2</code> paths. Sometimes it gets this wrong, e.g.:</p> <pre><code>command.exe /switch\n</code></pre> <p>Explanation: <code>/switch</code> is a Windows style switch. Note that Windows programs commonly accept unambiguous dash-prefixed switches (<code>-switch</code>) as well.</p> <pre><code>adb push readme.txt /sdcard/0/\n</code></pre> <p>Explanation: <code>/sdcard/0/</code> is a path on a foreign system.</p> <pre><code>./configure --root=/\n</code></pre> <p>Explanation: The value of root (<code>/</code>) is emitted to a text file via echo (which is an <code>msys2</code> program and hence not mangled) and also to a <code>Makefile</code> (through autotools) which passes it to a native program, which reads the text file replacing each instance of <code>/</code> with \"some-other-path\". This will go wrong as <code>/</code> passed to the native program was converted to e.g. <code>C:/msys64/</code> and therefore the necessary substitutions did not happen. [last sentence needs review or rewording]</p> <p>To work around this, path conversion can be selectively disabled. MSYS2 reads an environment variable called <code>MSYS2_ARG_CONV_EXCL</code>. This is a <code>;</code> delimited string each part of which is compared against the front part of each argument and if a match is found, that conversion is skipped. An example of a value for <code>MSYS2_ARG_CONV_EXCL</code> that would inhibit path transformations of the 3 cases above is <code>/switch;/sdcard;--root=</code>.</p> <p>Setting <code>MSYS2_ARG_CONV_EXCL=*</code> prevents any path transformation.</p> <p>The development repository for this path conversion code is https://github.com/Alexpux/path_convert. If you find a case that you think is unambiguously being converted incorrectly, please raise an issue there and/or a pull request with the broken test-case.</p>"},{"location":"wiki/Porting/#hard-coded-paths-and-relocation","title":"Hard-coded paths and relocation","text":"<p>When installing MSYS2, the user selects the root folder. POSIX software has a habit of baking the installation paths into the packages at build time, which is okay for <code>msys2</code> software (which only sees the single-root virtual filesystem), but usually causes failures in native software. When a program tries to load its data files using these absolute paths on another MSYS2 installed to a different root folder, it won't find them. For this reason, adding path relocation patches is a common necessity for <code>mingw</code> packages (but never for <code>msys2</code> packages). The point is to find the path where the program's executable resides, cutting off the <code>/bin</code> from the end and finding all necessary files using paths relative to that. Since this is a pretty common task and is not exactly trivial to get it right for all cases, we wrote some re-usable C code for that, available at https://github.com/msys2/MINGW-packages/tree/master/mingw-w64-pathtools.</p> <p>Sometimes these paths are baked into shell scripts or pkg-config's <code>.pc</code> files. In that case, you should use sed in the <code>PKGBUILD</code> <code>package()</code> function to correct this back to the <code>msys2</code> version of the path. [please review last sentence] An example of this can be seen at https://github.com/msys2/MINGW-packages/blob/e0280472a1912cfcd9e714f6e0d06c407326e0df/mingw-w64-libtool/PKGBUILD#L79.</p>"},{"location":"wiki/Porting/#c-printf-format-specifier-issues","title":"C *printf Format Specifier issues","text":"<p>The vc6.0 msvcrt.dll that MinGW-w64 targets doesn't implement support for the ANSI standard format specifiers. MinGW-w64 works around this by providing their own implementation. To enable this you should pass -D__USE_MINGW_ANSI_STDIO=1 to the MinGW-w64 C and C++ compilers. All of our C/C++ packages are built with this flag.</p>"},{"location":"wiki/Porting/#different-size-of-struct-timeval","title":"Different size of struct timeval","text":"<p>The Windows (and thus mingw-w64) <code>struct timeval</code> is defined as having two <code>long</code> members, while the POSIX specs say it's supposed to have one <code>time_t</code> and one <code>suseconds_t</code> member. This means that on 64-bit, the size of the struct will be different from what you would expect on Linux/Cygwin/MSYS2.</p> <p>struct timeval on MSDN struct timeval on OpenGroup.org</p>"},{"location":"wiki/Porting/#more-3264-bit-peculiarities","title":"More 32/64 bit peculiarities","text":"<p>Sorting out the stat thing by LRN: https://archive.li/IsgPq</p> <p>(Original URL - now down: <code>https://gnunet.org/sorting-out-stat-thing</code>)</p>"},{"location":"wiki/Porting/#calling-conventions-stdcall-and-autotools","title":"Calling conventions, stdcall, and autotools","text":"<p>Details about Windows' 32bit calling conventions: http://www.willus.com/mingw/yongweiwu_stdcall.html</p> <p>Problems stdcall causes with autotool's AC_CHECK_FUNC and AC_SEARCH_LIBS: http://lists.gnu.org/archive/html/autoconf/2013-05/msg00090.html</p>"},{"location":"wiki/Porting/#macroinline-function-and-autotools","title":"Macro/inline function and autotools","text":"<p><code>AC_CHECK_FUNCS</code> and friends can't deal with function macros and static inline functions (because the checking code tries to <code>#undef</code> the symbol, doesn't include any headers and declares the symbol as extern instead). Possible solution is replacing them with more elaborate checks using <code>AC_LINK_IFELSE</code> or <code>AC_COMPILE_IFELSE</code>. For example this:</p> <pre><code>AC_CHECK_FUNCS([localtime_r],\n[AM_CONDITIONAL([HAVE_LOCALTIME_R], true)],\n[AM_CONDITIONAL([HAVE_LOCALTIME_R], false)])\n</code></pre> <p>... can be replaced with this:</p> <pre><code>AC_MSG_CHECKING([for localtime_r])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n  #include &lt;time.h&gt;\n]], [[\n  time_t t; struct tm r;\n  localtime_r(&amp;t, &amp;r);\n]])],\n[AC_MSG_RESULT([yes])\n AM_CONDITIONAL([HAVE_LOCALTIME_R], true)\n AC_DEFINE([HAVE_LOCALTIME_R], [1], [Define to 1 if you have the `localtime_r' function or macro.])],\n[AC_MSG_RESULT([no])\n AM_CONDITIONAL([HAVE_LOCALTIME_R], false)])\n</code></pre> <p>Don't forget to <code>autoreconf -fi</code> after patching <code>configure.ac</code>.</p> <p>A tidy workaround from flameeyes for asprintf/vasprintf (but generally applicable): https://mailman.videolan.org/pipermail/vlc-devel/2015-March/101802.html</p>"},{"location":"wiki/Porting/#guarded-time-functions-ansi-format-specifiers","title":"Guarded time functions, ANSI format specifiers","text":"<p>Some things in mingw-w64 are (maybe unexpectedly) guarded by <code>#ifdef</code>s. Check out <code>_POSIX_C_SOURCE</code>, <code>__USE_MINGW_ANSI_STDIO</code>, the <code>time.h</code> file. Note that (at the time of writing) <code>pthread.h</code> contains some defines that affect the definitions in <code>time.h</code>.</p>"},{"location":"wiki/Porting/#undefined-references-and-linking-to-dllssos","title":"Undefined references and linking to DLLs/SOs","text":"<p>[this section may contain misinformations; it needs review from a knowledgeable person]</p> <p>Linux/ELF platforms generally don't do anything special to link to shared objects, they just leave the undefined references in the binary. Windows however requires all references to be resolved at link time. In case of DLLs, this is solved by the .dll.a import libraries that add the relevant .dll to the binary's import table and insert correct calls into the code, but it needs that correct linker flags be passed when linking binaries. Note that the linker is aware of these files and will use them automatically when using the standard <code>-l</code> arguments, for example <code>-lfoo</code> will make the linker check for <code>libfoo.dll.a</code> and <code>libfoo.a</code>, in this order (unless specified otherwise).</p> <p>Libtool generally refuses to create DLLs unless <code>-no-undefined</code> is passed to the linker invocation (<code>library_la_LDFLAGS = -no-undefined</code>). See: https://lists.gnu.org/archive/html/libtool/2007-04/msg00066.html</p>"},{"location":"wiki/Porting/#library-prefixes","title":"Library prefixes","text":"<p><code>mingw</code> DLLs follow the convention of prefixing libraries with <code>lib</code>. This affects shared libraries (<code>.dll</code>), static object archives (<code>.a</code>), and DLL import libraries (<code>.dll.a</code>). Because <code>msys2</code> DLLs are generally ABI-incompatible with everything from outside of <code>msys2</code>, they are prefixed with <code>msys2-</code> instead. For completeness, we note that Cygwin DLLs are prefixed with <code>cyg</code>.</p> <p>[does libtool or the linker handle this automatically?]</p>"},{"location":"wiki/Porting/#standard-streams-in-mintty","title":"Standard streams in mintty","text":"<p>mintty is primarily designed to be a good terminal emulator (in the POSIX sense of the word) and it works well with bash, ssh and other Cygwin/MSYS2 programs. Because native Windows console programs use a fundamentally different way of handling console input/output, mintty uses pipes to connect to their standard streams (stdin, stdout, stderr). Unfortunately, this has the effect that <code>isatty</code> and similar APIs (used to check whether a stream is attached to an interactive console or a pipe/file) will return incorrect values for native programs running under mintty.</p> <p>One way of fixing this problem is to run native programs inside a real Windows console, hide the console and use the console API to communicate with the program. This approach has obvious disadvantages, but it's good enough. Actually, this is the way most Windows console emulators work (e.g. ConsoleZ, ConEmu). There is also a wrapper program called winpty that does exactly this and translates the I/O to/from standard terminal sequences which mintty understands.</p> <p>Running a program under winpty (by prefixing the command line with <code>winpty</code>) will make the program think it is running interactively, but it will also break any special features depending on terminal sequences, possibly including colored text output and TUIs.</p> <p>MSYS2 includes wrappers for some affected programs, so that they will work correctly most of the time. Examples can be seen in packages containing REPLs (python3, lua, nodejs, ...).</p> <p>mintty issue #56, original on Google Code</p> <p>winpty on GitHub</p>"},{"location":"wiki/Porting/#response-files","title":"Response files","text":"<p>When passing arguments with absolute paths to native Windows programs (such as <code>/mingw64/bin/gcc</code>), these paths  get (in most cases) automatically converted by MSYS2 if they're in POSIX format. However, if you're passing these paths inside a file (e.g. a response file for GCC -- <code>gcc @somefile</code>), they need to be pre-converted to Windows native format.</p> <p>discussion topic: gcc -I (eye) uses msys2 path or windows path?</p>"},{"location":"wiki/Porting/#setting-floating-point-precision","title":"Setting floating point precision","text":"<p>Floating point precision issues with multiple threads: gfortran, open mp and floating point precision by Carl Kleffner:</p> <ul> <li>https://sourceforge.net/p/mingw-w64/mailman/message/33332276/</li> <li>https://gcc.gnu.org/wiki/FloatingPointMath</li> <li>https://gcc.gnu.org/wiki/x87note</li> </ul>"},{"location":"wiki/Porting/#command-line-parsing","title":"Command line parsing","text":"<p>Windows programs parse the command line themselves, it isn't parsed for them by the calling process, as on Linux. This means that if wildcards (glob patterns) are to be accepted by the program, it has to be able to expand them somehow. MinGW-w64 supplies the correct start-up code, so it happens automatically, in a manner compatible with MSVC-compiled programs. If undesirable, the behavior can be disabled at program build.</p> <p>Cygwin/MSYS2 programs have to deal with a mix of both approaches, but they can apparently deal with it. Note that they don't behave exactly like native programs, for example they understand single-quoted arguments.</p> <p>\"How Command Line Parameters Are Parsed\" by David Deley</p> <p>\"Everyone quotes command line arguments the wrong way\" by Daniel Colascione</p>"},{"location":"wiki/Porting/#other-resources","title":"Other resources","text":"<p>A collection of articles on general C and C++ topics. http://locklessinc.com/articles/</p> <p>The MinGW-w64 project's wiki. http://sourceforge.net/p/mingw-w64/wiki2/browse_pages/</p>"},{"location":"wiki/Setting-up-SSHd/","title":"Setting up SSHd","text":"<p>One can connect to MSYS2 via Win32-OpenSSH by creating a batch file (e.g. C:\\msys64\\sshd_default_shell.cmd) containing <code>@C:\\msys64\\msys2_shell.cmd -defterm -here -no-start -mingw64</code> (you can change -mingw64 to the environment of your choice) and then setting the registry entry HKEY_LOCAL_MACHINE\\SOFTWARE\\OpenSSH\\DefaultShell to the path of that batch file.</p> <p>MSYS2 can also use its own OpenSSHd.  Use the set-up script below.</p> <pre><code>#!/bin/sh\n#\n#  msys2-sshd-setup.sh \u2014 configure sshd on MSYS2 and run it as a Windows service\n#\n#  Replaces ssh-host-config &lt;https://github.com/openssh/openssh-portable/blob/master/contrib/cygwin/ssh-host-config&gt;\n#  Adapted from &lt;https://ghc.haskell.org/trac/ghc/wiki/Building/Windows/SSHD&gt; by Sam Hocevar &lt;sam@hocevar.net&gt;\n#  Adapted from &lt;https://gist.github.com/samhocevar/00eec26d9e9988d080ac&gt; by David Macek\n#\n#  Prerequisites:\n#    \u2014 a 64-bit installation of MSYS2 itself: https://msys2.org\n#    \u2014 some packages: pacman -S openssh cygrunsrv mingw-w64-x86_64-editrights\n#\n#  Gotchas:\n#    \u2014 the log file will be /var/log/msys2_sshd.log\n#    \u2014 if you get error \u201csshd: fatal: seteuid XXX : No such device or address\u201d\n#      in the logs, try \u201cpasswd -R\u201d (with admin privileges)\n#    \u2014 if you get error \u201cchown(/dev/pty1, XXX, YYY) failed: Invalid argument\u201d\n#      in the logs, make sure your account and group names are detectable (see\n#      `id`); issues are often caused by having /etc/{passwd,group} or having\n#      a modified /etc/nsswitch.conf\n#\n#  Changelog:\n#   09 May 2020 \u2014 completely remove additional privileged user\n#   16 Apr 2020 \u2014 remove additional privileged user\n#               \u2014 only touch /etc/{passwd,group} if they exist\n#   27 Jun 2019 \u2014 rename service to msys2_sshd to avoid conflicts with Windows OpenSSH\n#               \u2014 use mkgroup.exe as suggested in the comments\n#               \u2014 fix a problem with CRLF and grep\n#   24 Aug 2015 \u2014 run server with -e to redirect logs to /var/log/sshd.log\n#\n\nset -e\n\n#\n# Configuration\n#\n\nUNPRIV_USER=sshd # DO NOT CHANGE; this username is hardcoded in the openssh code\nUNPRIV_NAME=\"Privilege separation user for sshd\"\n\nEMPTY_DIR=/var/empty\n\n\n#\n# Check installation sanity\n#\n\nif ! /mingw64/bin/editrights -h &gt;/dev/null; then\n    echo \"ERROR: Missing 'editrights'. Try: pacman -S mingw-w64-x86_64-editrights.\"\n    exit 1\nfi\n\nif ! cygrunsrv -v &gt;/dev/null; then\n    echo \"ERROR: Missing 'cygrunsrv'. Try: pacman -S cygrunsrv.\"\n    exit 1\nfi\n\nif ! ssh-keygen -A; then\n    echo \"ERROR: Missing 'ssh-keygen'. Try: pacman -S openssh.\"\n    exit 1\nfi\n\n\n#\n# The unprivileged sshd user (for privilege separation)\n#\n\nadd=\"$(if ! net user \"${UNPRIV_USER}\" &gt;/dev/null; then echo \"//add\"; fi)\"\nif ! net user \"${UNPRIV_USER}\" ${add} //fullname:\"${UNPRIV_NAME}\" \\\n              //homedir:\"$(cygpath -w ${EMPTY_DIR})\" //active:no; then\n    echo \"ERROR: Unable to create Windows user ${UNPRIV_USER}\"\n    exit 1\nfi\n\n\n#\n# Add or update /etc/passwd entries\n#\n\nif test -f /etc/passwd; then\n    sed -i -e '/^'\"${UNPRIV_USER}\"':/d' /etc/passwd\n    SED='/^'\"${UNPRIV_USER}\"':/s?^\\(\\([^:]*:\\)\\{5\\}\\).*?\\1'\"${EMPTY_DIR}\"':/bin/false?p'\n    mkpasswd -l -u \"${UNPRIV_USER}\" | sed -e 's/^[^:]*+//' | sed -ne \"${SED}\" \\\n             &gt;&gt; /etc/passwd\n    mkgroup.exe -l &gt; /etc/group\nfi\n\n\n#\n# Finally, register service with cygrunsrv and start it\n#\n\ncygrunsrv -R msys2_sshd || true\ncygrunsrv -I msys2_sshd -d \"MSYS2 sshd\" -p /usr/bin/sshd.exe -a \"-D -e\" -y tcpip\n\n# The SSH service should start automatically when Windows is rebooted. You can\n# manually restart the service by running `net stop msys2_sshd` + `net start msys2_sshd`\nif ! net start msys2_sshd; then\n    echo \"ERROR: Unable to start msys2_sshd service\"\n    exit 1\nfi\n</code></pre>"},{"location":"wiki/Signing-packages/","title":"Signing Packages","text":"<p>[ rough draft ]</p>"},{"location":"wiki/Signing-packages/#have-a-gpg-key","title":"Have a GPG key","text":"<p>Create your new key: <code>gpg --gen-key</code> more... [ TBD: how strong should the key be? ]</p> <p>Back it up: <code>gpg --export-secret-keys --armor &lt;keyid&gt; &gt; my_key_backup.asc</code> more...</p> <p>In case you need to import the backup later: <code>gpg --import &lt;backup_file&gt;</code>, <code>gpg --edit-key &lt;keyid&gt;</code> and <code>trust</code> it ultimately.</p> <p>Export the public key: <code>gpg --export --armor &lt;keyid&gt; &gt; my_pub_key.asc</code></p> <p>If you're going to use the key for GPG/MIME or share your signed packages with other people, you probably need to publish your key: <code>gpg --send-key &lt;keyid&gt;</code> more...</p>"},{"location":"wiki/Signing-packages/#import-into-pacman","title":"Import into pacman","text":"<p>This is needed because pacman has its own keystore and own rules for trusting keys. Either you get approved as a packager for the MSYS2 project, or you have to import your key manually.</p> <p>To import and sign your key with <code>pacman-key</code>:</p> <ol> <li><code>pacman-key --add &lt;pubkeyfile&gt;</code>, or if it's published <code>pacman-key --recv-keys &lt;keyid&gt;</code></li> <li><code>pacman-key --lsign-key &lt;keyid&gt;</code> more...</li> </ol> <p>To make your key a trusted developer key for signing official packages, you have to get your key included in the respective keyring and get it signed by at least 3 master keys. The package and repository is <code>msys2-keyring</code> for MSYS2, see Alexpux/msys2-keyring. The package and repository for Arch Linux is <code>archlinux-keyring</code>, see https://projects.archlinux.org/archlinux-keyring.git/. These packages install keyring files into <code>/usr/share/pacman/keyrings</code> which then can be imported and locally signed in one batch using <code>pacman-key --populate &lt;keyringname&gt;</code>.</p>"},{"location":"wiki/Signing-packages/#actually-sign-stuff","title":"Actually sign stuff","text":"<ul> <li>Old packages: <code>gpg --detach-sign --no-armor &lt;pkg&gt;</code> for each package (all such packages need to be re-<code>repo-add</code>ed to make the database aware of the new signatures)</li> <li>New packages: just add <code>--sign</code> to makepkg command line or set the related <code>makepkg.conf</code> option</li> <li>Databases: <code>repo-add -s -v &lt;db&gt; &lt;pkg&gt;</code></li> </ul>"},{"location":"wiki/Sudo/","title":"Do you need Sudo?","text":""},{"location":"wiki/Sudo/#do-you-need-sudo_1","title":"Do you need Sudo?","text":"<p>In regular GNU/Linux environments, people use <code>sudo</code> to perform administrative tasks on their system, e.g. installing and removing packages, editing system configuration.  Since the most common way of installing MSYS2 results in the MSYS2 root directory being writable by the user, these tasks can be performed without doing anything special.  If you made your MSYS2 root read only for users or want to run Windows administrative tasks from MSYS2, continue reading.</p>"},{"location":"wiki/Sudo/#how-to-get-sudo","title":"How to get Sudo","text":"<p>Since MSYS2 doesn't support all the things a classic Sudo needs (setuid? PAM?), we need a replacement.  One such replacement that doesn't seem to suffer from horrible security flaws is win-sudo.  It doesn't support (as of May 2020) the various different arguments (<code>-H</code>, <code>-u</code> etc.), but it does work in the most common use case of <code>sudo foo</code> running <code>foo</code> with elevated privileges.  The authorization is handled by UAC, same as any other Windows program.</p>"},{"location":"wiki/Terminals/","title":"Terminals","text":"<p>This is a basic explanation of how console programs work in Cygwin and MSYS2. GUI (graphical, windowed) programs fall outside of the scope of this text.</p> <p>Note that this topic is not simple and there are many factors that can cause differences in observed behavior (<code>TERM</code>, <code>LANG</code>, <code>LC_*</code>...). The following information is our best understanding and our best attempt at explaining it. If the reader has any corrections or clarifications, please post to the mailing list. Note that where we say MSYS2 below, it usually denotes Cygwin as well.</p> <p>MSYS2 (more generally POSIX) and regular Windows (i.e. non-MSYS2 ones) console programs both use character streams to read data from the user and to display data to the user. If reading and writing simple text is the only thing a program does (i.e. it's not interactive), then the program's I/O should be easily portable between Windows, MSYS2 and other platforms.</p> <p>On a more advanced level, e.g. when a program employs a REPL or uses colored output or draws TUIs, the two systems are fundamentally different. MSYS2/POSIX programs use in-band terminal sequences, while Windows programs use out-of-band calls to the Windows Console API. In the POSIX world, REPLs are often programmed using the readline library and TUIs using the ncurses library.</p>"},{"location":"wiki/Terminals/#terminals_1","title":"Terminals","text":"<p>Terminals are programs that interface with console programs and facilitate their input (e.g. accept keypresses from the user and send corresponding characters to the program) and output (e.g. draw the characters from the programs as corresponding glyphs on the screen).</p> <p>Mintty is a terminal emulator built for MSYS2 programs. It provides the necessary POSIX interfaces to MSYS2 programs. There are other terminal emulators in Cygwin, but they're not provided in MSYS2.</p> <p>The Windows console (conhost) does the same for Windows programs. It provides the back-end to the Windows Console API.</p>"},{"location":"wiki/Terminals/#shells","title":"Shells","text":"<p>A distinct category of programs is shells. A shell is the actual program that reads commands from the user and runs them.</p> <p>The \"DOS window\" in Windows is actually a combination of a Windows console and the Windows shell (cmd, command line). Likewise, when you open a mintty window, you'll probably see the bash shell running inside and waiting for your commands. This matching is not mandatory though, as bash can be run in a Windows console and cmd can be run in mintty.</p>"},{"location":"wiki/Terminals/#mixing-msys2-and-windows","title":"Mixing MSYS2 and Windows","text":"<p>MSYS2 allows some inter-operation between a MSYS2 program and Windows console and between a Windows program and MSYS2 terminal emulators. For basic stuff, it works fine. Anything more complicated, like colored text, TUIs and line editing, is a lottery -- it can work, it can break.</p> <p>Winpty is a wrapper program that works as a translator between Windows programs and MSYS2 terminals. It opens an invisible Windows console window and runs the wrapped program in it. It then relays input from the terminal to the program and output from the program to the terminal. This solves a lot of the issues of running Windows programs in a MSYS2 terminal.</p>"},{"location":"wiki/arm64/","title":"ARM64 Support","text":"<p>MSYS2 has preliminary ARM64/AArch64 support. Lots of MSYS2 packages have native ARM64 builds available and you can build your own programs for ARM64 Windows. Give it a try and let us know if there are any issues.</p> <p>Requirements:</p> <ul> <li>Windows 11 ARM64</li> </ul> <p>Installation:</p> <ul> <li>Download/Install MSYS2 as usual</li> <li>Execute <code>clangarm64.exe</code> in the MSYS2 install directory</li> <li>Run <code>pacman -Suy</code></li> <li>Install clang for example: <code>pacman -S mingw-w64-clang-aarch64-clang</code></li> </ul>"},{"location":"wiki/arm64/#known-issues","title":"Known Issues","text":"<ul> <li>Not all packages in the repo have native builds yet, let us know if any you need are missing.</li> <li>All unixy tools, like bash, will go through x64 emulation, so they might run slower than expected.</li> <li>Windows 10 ARM64 isn't supported since we require x64 emulation, which was added in Windows 11. The MinGW packages and anything you build yourself should support Windows 10 ARM64 though.</li> </ul>"}]}